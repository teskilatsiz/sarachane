<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Saraçhane</title>
    <meta name="description" content="Saraçhane, polis ve protestocu arasındaki etkileşimi konu alan, sandbox tarzı bir hayatta kalma oyunudur. Slogan atarak direnişe katıl!">

    <meta property="og:title" content="Saraçhane">
    <meta property="og:description" content="Saraçhane, polis ve protestocu arasındaki etkileşimi konu alan, sandbox tarzı bir hayatta kalma oyunudur. Slogan atarak direnişe katıl!">
    <meta property="og:image" content="https://i.hizliresim.com/sa8fiz7.png">
    <meta property="og:url" content="https://sarachane.vercel.app/">
    <meta property="og:type" content="website">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Saraçhane">
    <meta name="twitter:description" content="Saraçhane, polis ve protestocu arasındaki etkileşimi konu alan, sandbox tarzı bir hayatta kalma oyunudur. Slogan atarak direnişe katıl!">
    <meta name="twitter:image" content="https://i.hizliresim.com/sa8fiz7.png">
    <meta name="twitter:url" content="https://sarachane.vercel.app/">
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: white; image-rendering: pixelated; -ms-interpolation-mode: nearest-neighbor; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; touch-action: none; }
        canvas { display: block; image-rendering: pixelated; -ms-interpolation-mode: nearest-neighbor; }

        #engelleyici, #olumEkrani, #basariEkrani { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: flex; justify-content: center; align-items: center; text-align: center; z-index: 100; pointer-events: none; flex-direction: column; }
        #olumEkrani { background-color: rgba(100, 0, 0, 0.9); display: none; pointer-events: auto; }
        #basariEkrani { background: linear-gradient(135deg, rgba(0, 100, 200, 0.9), rgba(50, 180, 255, 0.95)); display: none; pointer-events: auto; }
        #olumMesaji, #basariMesaji { font-size: clamp(3em, 15vw, 6em); color: #ffcccc; font-weight: bold; text-shadow: 3px 3px 8px black; margin-bottom: 40px; letter-spacing: 4px; animation: fadeInOverlayText 1s ease-out; }
        #basariMesaji { color: #ccffcc; }
        @keyframes fadeInOverlayText { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }

        #yenidenBaslatButonu, #anaMenuyeDonButonu { padding: clamp(10px, 3vw, 15px) clamp(25px, 6vw, 35px); font-size: clamp(1em, 4vw, 1.5em); color: #fff; background: linear-gradient(145deg, #ff8800, #cc6000); border: none; border-radius: 5px; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.4), inset 0 1px 1px rgba(255,255,255,0.3); transition: background 0.2s, transform 0.1s; font-weight: bold; margin-top: 20px; }
        #yenidenBaslatButonu:hover, #anaMenuyeDonButonu:hover { background: linear-gradient(145deg, #ffa033, #e67e00); }
        #yenidenBaslatButonu:active, #anaMenuyeDonButonu:active { transform: scale(0.98); box-shadow: 0 2px 3px rgba(0,0,0,0.3), inset 0 1px 1px rgba(0,0,0,0.2); }
        #anaMenuyeDonButonu { background: linear-gradient(145deg, #4CAF50, #388E3C); }
        #anaMenuyeDonButonu:hover { background: linear-gradient(145deg, #66BB6A, #4CAF50); }

        #menuArayuzu { background-color: rgba(40, 40, 45, 0.97); padding: clamp(15px, 4vw, 30px) clamp(20px, 5vw, 40px); border: 1px solid #666; border-radius: 8px; box-shadow: 0 10px 25px rgba(0,0,0,0.7); width: 90%; max-width: 550px; pointer-events: auto; animation: fadeInMenu 0.5s ease-out; max-height: 90vh; overflow-y: auto; }
         @keyframes fadeInMenu { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
        #menuArayuzu h1 { margin-top: 0; margin-bottom: clamp(15px, 4vw, 35px); font-size: clamp(1.8em, 7vw, 3em); color: #ffcc00; text-shadow: 2px 2px 5px rgba(0,0,0,0.8); letter-spacing: 2px; font-family: 'Poppins', sans-serif; }
        #menuArayuzu p { margin-bottom: 15px; font-size: clamp(0.8em, 2.5vw, 1em); color: #ccc; line-height: 1.4; }
        .menu_butonu { display: block; width: 80%; max-width: 250px; margin: 15px auto; padding: clamp(10px, 3vw, 14px) clamp(15px, 4vw, 25px); background: linear-gradient(145deg, #5a5a5a, #3a3a3a); color: white; border: none; border-radius: 5px; font-size: clamp(1em, 3.5vw, 1.2em); cursor: pointer; transition: background 0.2s, transform 0.1s; box-shadow: 0 3px 5px rgba(0,0,0,0.4), inset 0 1px 1px rgba(255,255,255,0.1); font-weight: bold; }
        .menu_butonu:hover { background: linear-gradient(145deg, #6f6f6f, #4f4f4f); }
        .menu_butonu:active { transform: scale(0.98); box-shadow: 0 1px 2px rgba(0,0,0,0.3), inset 0 1px 1px rgba(0,0,0,0.1); }

         #ayarlarIcerigi { display: none; margin-top: 25px; padding: clamp(15px, 3vw, 25px); background-color: rgba(0,0,0,0.3); border-radius: 5px; text-align: left; border: 1px solid #555; }
         #ayarlarIcerigi p { font-size: clamp(0.75em, 2.3vw, 0.9em); margin-bottom: 10px; color: #ddd; }
         #ayarlarIcerigi strong { color: #fff; font-weight: 600; }
         .ayar_ogesi { display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; margin-bottom: 12px; padding: 5px 0; }
         .ayar_ogesi label { margin-right: 15px; color: #ccc; flex-shrink: 0; margin-bottom: 5px; font-size: clamp(0.75em, 2.3vw, 0.9em); }
         .ayar_ogesi input[type="range"] { flex-grow: 1; min-width: 100px; max-width: 180px; cursor: pointer; height: 6px; background: #555; border-radius: 3px; outline: none; -webkit-appearance: none; appearance: none; border: 1px solid black; }
         .ayar_ogesi input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 14px; height: 14px; background: #bbb; border-radius: 50%; cursor: pointer; border: 1px solid black; box-shadow: 0 0 3px rgba(0,0,0,0.5); }
         .ayar_ogesi input[type="range"]::-moz-range-thumb { width: 14px; height: 14px; background: #bbb; border-radius: 50%; cursor: pointer; border: 1px solid black; box-shadow: 0 0 3px rgba(0,0,0,0.5); }
         .ayar_ogesi span { min-width: 40px; text-align: right; color: #eee; font-size: clamp(0.75em, 2.3vw, 0.9em); font-weight: bold; margin-left: 8px; }
         hr { border: none; border-top: 1px solid #555; margin: 20px 0; }
         .gelistirici_notu { font-size: clamp(0.7em, 2vw, 0.8em); color: #999; margin-top: 20px; text-align: center; }

        #bildirim { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background-color: rgba(255, 180, 30, 0.95); color: black; padding: 8px 15px; border-radius: 5px; font-size: clamp(0.9em, 2.5vw, 1.1em); font-weight: bold; text-shadow: 1px 1px 0px rgba(255,255,255,0.6); display: none; z-index: 50; opacity: 0; transition: opacity 0.3s ease-out, top 0.3s ease-out; pointer-events: none; border: 1px solid black; box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        #biberGaziKaplamasi { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(ellipse at center, rgba(255,180,50,0.1) 0%, rgba(255,165,0,0.6) 70%, rgba(220,120,0,0.8) 100%); opacity: 0; transition: opacity 0.2s ease-in-out; pointer-events: none; z-index: 10; display: none; }
        .durum_cubuklari_kapsayici { position: absolute; bottom: 20px; left: 50%; width: clamp(200px, 60vw, 300px); transform: translateX(-50%); display: none; justify-content: space-between; pointer-events: none; z-index: 5; height: 15px; gap: 6px; }
        .durum_cubugu_dis { height: 100%; width: calc(50% - 3px); background-color: rgba(20,20,20,0.85); border: 1px solid #888; border-radius: 3px; box-sizing: border-box; overflow: hidden; box-shadow: inset 0 1px 3px rgba(0,0,0,0.7); }
        .durum_cubugu_ic { height: 100%; width: 100%; transition: width 0.15s linear; border-radius: 2px; }
        #canCubuguIc { background: linear-gradient(to right, #e74c3c, #c0392b); }
        #dayaniklilikCubuguIc { background: linear-gradient(to right, #f1c40f, #f39c12); }
        #hasarKaplamasi { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(200, 0, 0, 0.5); opacity: 0; transition: opacity 0.05s ease-out; pointer-events: none; z-index: 9; display: none; }

        #sloganSeviyeKapsayici {
            position: absolute;
            bottom: 45px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 5;
            pointer-events: none;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 6px 12px;
            border-radius: 5px;
            border: 1px solid #555;
            width: clamp(200px, 60vw, 300px);
        }
        #seviyeCubuguDis {
            width: 100%;
            height: 8px;
            background-color: rgba(20,20,20,0.85);
            border: 1px solid #888;
            border-radius: 3px;
            box-sizing: border-box;
            overflow: hidden;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.7);
            margin-bottom: 4px;
        }
        #seviyeCubuguIc {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            transition: width 0.2s linear;
            border-radius: 2px;
        }
        #sloganPuanText, #kalanPuanText {
            font-size: clamp(0.65em, 2vw, 0.8em);
            color: #eee;
            text-shadow: 1px 1px 1px black;
            line-height: 1.2;
            width: 100%;
            text-align: center;
        }
        #kalanPuanText { color: #ffcc00; }


        #mobilKontroller {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 150px;
            display: none;
            pointer-events: none;
            z-index: 20;
        }
        #joystickAlani {
            position: absolute;
            bottom: 20px;
            left: 15px;
            width: 110px;
            height: 110px;
            pointer-events: auto;
        }
        #joystickTabani {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(100, 100, 100, 0.3);
            border-radius: 50%;
            border: 2px solid rgba(200, 200, 200, 0.4);
        }
        #joystickCubugu {
            position: absolute;
            width: 55px;
            height: 55px;
            background-color: rgba(200, 200, 200, 0.6);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #kosuButonu {
            position: absolute;
            bottom: 90px;
            right: 25px;
            width: 65px;
            height: 65px;
            background-color: rgba(255, 165, 0, 0.5);
            border-radius: 50%;
            border: 2px solid rgba(255, 200, 100, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 0.9em;
            font-weight: bold;
            pointer-events: auto;
            text-shadow: 1px 1px 2px black;
            -webkit-tap-highlight-color: transparent;
        }
        #kosuButonu:active { background-color: rgba(255, 140, 0, 0.7); }
        #ziplamaButonu {
            position: absolute;
            bottom: 20px;
            right: 105px;
            width: 65px;
            height: 65px;
            background-color: rgba(0, 150, 255, 0.5);
            border-radius: 50%;
            border: 2px solid rgba(100, 180, 255, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 0.9em;
            font-weight: bold;
            pointer-events: auto;
            text-shadow: 1px 1px 2px black;
            -webkit-tap-highlight-color: transparent;
        }
        #ziplamaButonu:active { background-color: rgba(0, 120, 200, 0.7); }
        #sloganAtButonu {
            position: absolute;
            bottom: 20px;
            right: 25px;
            width: 65px;
            height: 65px;
            background-color: rgba(70, 180, 70, 0.6);
            border-radius: 50%;
            border: 2px solid rgba(120, 220, 120, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 0.8em;
            font-weight: bold;
            pointer-events: auto;
            text-shadow: 1px 1px 2px black;
            -webkit-tap-highlight-color: transparent;
            text-align: center;
            line-height: 1.1;
            padding: 0 5px;
            box-sizing: border-box;
        }
        #sloganAtButonu:active { background-color: rgba(50, 150, 50, 0.8); }

        #yonlendirmeUyarisi { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.95); color: white; display: none; justify-content: center; align-items: center; text-align: center; z-index: 200; font-size: 1.2em; padding: 20px; box-sizing: border-box; }
        #yonlendirmeUyarisi p { max-width: 80%; }

    </style>
</head>
<body>
    <div id="engelleyici" style="display: flex;">
        <div id="menuArayuzu">
            <h1>SⒶRⒶÇHⒶNE</h1>
            <p>Polislerin yakınındayken slogan atarak Ekrem İmamoğlu'nun serbest kalmasına yardımcı ol!</p>
            <button id="baslatButonu" class="menu_butonu">Direnişe Katıl</button>
            <button id="ayarlarButonu" class="menu_butonu">Ayarlar</button>
            <div id="ayarlarIcerigi">
                 <p><strong>Kontroller (PC):</strong></p>
                 <p>W, S = İleri / Geri | A, D = Sol / Sağ</p>
                 <p>SPACE = Zıplama | SHIFT = Hızlı Koşma</p>
                 <p>MOUSE = Bakış | ESC = Duraklat / Menü</p>
                 <p>SOL TIK = Slogan At (Polis yakınındaysa puan kazandırır)</p>
                 <hr>
                 <p><strong>Kontroller (Mobil):</strong></p>
                 <p>Sol Joystick = Hareket | Ekranı Kaydır = Bakış</p>
                 <p>Sağ Buton (Sarı) = Koşma | Sağ Buton (Mavi) = Zıplama</p>
                 <p>Sağ Buton (Yeşil) = Slogan At (Polis yakınındaysa puan kazandırır)</p>
                 <hr>
                 <p><strong>Oynanış:</strong> Polislerden ve biber gazından kaç! Polislerin yakınında slogan atarak puan topla. 500 puana ulaşarak Ekrem İmamoğlu'nu kurtar!</p>
                 <div class="ayar_ogesi">
                     <label for="kosmaKaydirici">Koşma Hızı:</label>
                     <input type="range" id="kosmaKaydirici" min="1.5" max="3.0" step="0.1" value="1.8">
                     <span id="kosmaHiziDegeri">1.8x</span>
                 </div>
                 <hr>
            </div>
             <p class="gelistirici_notu">Geliştirici: Teşkilatsız</p>
        </div>
    </div>

    <div id="olumEkrani" style="display: none;">
        <div id="olumMesaji">YAKALANDIN</div>
        <button id="yenidenBaslatButonu">Yeniden Başla</button>
    </div>

    <div id="basariEkrani" style="display: none;">
        <div id="basariMesaji">BAŞARDINIZ!</div>
        <p style="font-size: 1.2em; color: #fff; text-shadow: 1px 1px 3px black;">Ekrem İmamoğlu serbest bırakıldı!</p>
        <button id="anaMenuyeDonButonu">Ana Menüye Dön</button>
    </div>

    <div id="bildirim" style="display: none;"></div>
    <div class="durum_cubuklari_kapsayici" style="display: none;">
        <div id="canCubuguDis" class="durum_cubugu_dis"><div id="canCubuguIc" class="durum_cubugu_ic"></div></div>
        <div id="dayaniklilikCubuguDis" class="durum_cubugu_dis"><div id="dayaniklilikCubuguIc" class="durum_cubugu_ic"></div></div>
    </div>
    <div id="sloganSeviyeKapsayici" style="display: none;">
        <div id="seviyeCubuguDis"><div id="seviyeCubuguIc"></div></div>
        <div id="sloganPuanText">Slogan Puanı: 0</div>
        <div id="kalanPuanText">Serbest kalmasına kalan: 500</div>
    </div>

    <div id="hasarKaplamasi" style="display: none;"></div>
    <div id="biberGaziKaplamasi" style="display: none;"></div>

    <canvas id="oyunAlani"></canvas>

    <div id="mobilKontroller">
        <div id="joystickAlani">
            <div id="joystickTabani"></div>
            <div id="joystickCubugu"></div>
        </div>
        <div id="kosuButonu">Koş</div>
        <div id="ziplamaButonu">Zıpla</div>
        <div id="sloganAtButonu">Slogan At</div>
    </div>

    <div id="yonlendirmeUyarisi">
        <p>Lütfen cihazınızı yatay konuma çevirerek oynayın.</p>
    </div>

    <audio id="gazFirlatmaSesi" src="https://s188.convertio.me/p/GBic0U0E_qBrQq12Kp4iYA/b76c1307d72dedcc5c087f1b7f01bc14/mixkit-martial-arts-fast-punch-2047.mp3" preload="auto"></audio>
    <audio id="gazTislamaSesi" src="sesler/gaz_tislama.wav" preload="auto"></audio>
    <audio id="silahAtesSesi" src="https://s188.convertio.me/p/GBic0U0E_qBrQq12Kp4iYA/b76c1307d72dedcc5c087f1b7f01bc14/mixkit-martial-arts-fast-punch-2047.mp3" preload="auto"></audio>
    <audio id="mermiCarpmaSesi" src="sesler/mermi_carpma.wav" preload="auto"></audio>
    <audio id="mermiViziltiSesi" src="sesler/mermi_vizilti.wav" preload="auto"></audio>
    <audio id="oyuncuHasarSesi" src="https://s177.convertio.me/p/H6qc8C8U9FbxEmS8QTRPyQ/0fcfda7a3549a35fe1ae534fe7efba6c/mixkit-game-blood-pop-slide-2363.mp3" preload="auto"></audio>
    <audio id="polisHasarSesi" src="https://s177.convertio.me/p/H6qc8C8U9FbxEmS8QTRPyQ/0fcfda7a3549a35fe1ae534fe7efba6c/mixkit-game-blood-pop-slide-2363.mp3" preload="auto"></audio>
    <audio id="olumSesi" src="https://s185.convertio.me/p/ePZOZIRSqMn2aawJl5Ij7A/0fcfda7a3549a35fe1ae534fe7efba6c/mixkit-player-losing-or-failing-2042.mp3" preload="auto"></audio>
    <audio id="sloganSesi" src="https://s182.convertio.me/p/p1nVCElQVKnrr6-qv05jhA/0fcfda7a3549a35fe1ae534fe7efba6c/Hak-Hukuk-Adalet-remix-sanas%C3%B6z-ilkturdabitirelim-k%C4%B1l%C4%B1%C3%A7daro%C4%9Flu-rize-_mp3cut.net_.mp3" preload="auto"></audio>
    <audio id="basariSesi" src="https://s183.convertio.me/p/raxbqyCoYBRJhh6pzYouPQ/0fcfda7a3549a35fe1ae534fe7efba6c/success-fanfare-trumpets-6185.mp3" preload="auto"></audio>

    <script type="importmap">{"imports": {"three": "https://unpkg.com/three@0.160.0/build/three.module.js","three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"}}</script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        const CHUNK_SIZE = 16; const CHUNK_HEIGHT = 32; const WORLD_HEIGHT_VARIATION = 3;
        const NOISE_SCALE_GROUND = 0.1; const NOISE_SCALE_BUILDING = 0.12; const NOISE_SCALE_FOREST = 0.05;
        const RENDER_DISTANCE = 3; const PLAYER_HEIGHT = 1.6; const PLAYER_RADIUS = 0.35;
        const GRAVITY = -28; const JUMP_VELOCITY = 8.5; const MOVE_SPEED = 5.0;
        const SPRINT_MULTIPLIER_DEFAULT = 1.7;
        const COLLISION_EPSILON = 0.001;
        const MAX_HEALTH = 100; const MAX_STAMINA = 100;
        const STAMINA_DRAIN_RATE = 20; const STAMINA_REGEN_RATE = 10;
        const STAMINA_HEALTH_DRAIN_RATE = 7; const HEALTH_REGEN_RATE = 1.5;
        const HEALTH_REGEN_DELAY = 6; const MAX_POLICE = 12; const POLICE_SPAWN_CHANCE = 0.006;
        const POLICE_DETECT_RANGE = 22; const POLICE_ATTACK_RANGE_GAS = 14;
        const POLICE_ATTACK_RANGE_BULLET = 18; const POLICE_MOVE_SPEED = 4.0;
        const POLICE_ATTACK_COOLDOWN_GAS = 4.0; const POLICE_ATTACK_COOLDOWN_BULLET = 1.8;
        const PEPPER_SPRAY_DURATION = 4.5; const PEPPER_GAS_CLOUD_SIZE = 2.2;
        const PROJECTILE_MAX_LIFETIME = 4.0;
        const GAS_CAPSULE_SPEED = 20; const BULLET_SPEED = 50;
        const BLOOD_PARTICLE_COUNT = 20;
        const GAS_PARTICLE_COUNT = 100;
        const SPRINT_FOV_INCREASE = 5;
        const LOOK_SENSITIVITY = 0.0025;
        const POLICE_DAMAGE = { PEPPER_SPRAY_IMPACT: 1, PEPPER_SPRAY_DOT: 1.0, PLASTIC_BULLET: 9 };
        const PROJECTILE_TYPES = { GAS_CAPSULE: 1, POLICE_BULLET: 6 };
        const BLOCK_TYPES = { AIR: 0, ASPHALT: 10, SIDEWALK: 11, BUILDING_WALL_GRAY: 12, BUILDING_WALL_BRICK: 13, WINDOW: 14, PARK_GRASS: 15, METAL_FENCE: 16, DEBRIS: 17, CAR_BODY_WHITE: 18, CAR_BODY_BLUE: 19, CAR_WHEEL: 20, LAMP_POST: 21, POLICE_CAR_BODY: 22, POLICE_CAR_LIGHT_RED: 23, POLICE_CAR_LIGHT_BLUE: 24, TREE_TRUNK: 25, TREE_LEAVES: 26, POLICE_BARRIER: 27 };
        const BLOCK_COLORS = {[BLOCK_TYPES.ASPHALT]:{top:0x303030,side:0x252525,bottom:0x252525},[BLOCK_TYPES.SIDEWALK]:{top:0x9a9a9a,side:0x888888,bottom:0x888888},[BLOCK_TYPES.BUILDING_WALL_GRAY]:{top:0x858585,side:0x7a7a7a,bottom:0x7a7a7a},[BLOCK_TYPES.BUILDING_WALL_BRICK]:{top:0xa86048,side:0x985038,bottom:0x985038},[BLOCK_TYPES.WINDOW]:{top:0x5080cc,side:0x4070bb,bottom:0x4070bb},[BLOCK_TYPES.PARK_GRASS]:{top:0x408840,side:0x486838,bottom:0x486838},[BLOCK_TYPES.METAL_FENCE]:{top:0x666666,side:0x666666,bottom:0x666666},[BLOCK_TYPES.DEBRIS]:{top:0x555044,side:0x4a453a,bottom:0x4a453a},[BLOCK_TYPES.CAR_BODY_WHITE]:{top:0xcccccc,side:0xbbbbbb,bottom:0xbbbbbb},[BLOCK_TYPES.CAR_BODY_BLUE]:{top:0x3333cc,side:0x2222aa,bottom:0x2222aa},[BLOCK_TYPES.CAR_WHEEL]:{top:0x151515,side:0x101010,bottom:0x101010},[BLOCK_TYPES.LAMP_POST]:{top:0x777777,side:0x666666,bottom:0x666666},[BLOCK_TYPES.POLICE_CAR_BODY]:{top:0x2040cc,side:0x1030aa,bottom:0x1030aa}, [BLOCK_TYPES.POLICE_CAR_LIGHT_RED]:{top:0xff0000,side:0xcc0000,bottom:0xcc0000},[BLOCK_TYPES.POLICE_CAR_LIGHT_BLUE]:{top:0x0080ff,side:0x0060dd,bottom:0x0060dd}, [BLOCK_TYPES.TREE_TRUNK]: { top: 0x6B4423, side: 0x80512B, bottom: 0x6B4423 }, [BLOCK_TYPES.TREE_LEAVES]: { top: 0x228B22, side: 0x3CB371, bottom: 0x2E8B57 }, [BLOCK_TYPES.POLICE_BARRIER]: { top: 0xFFD700, side: 0xE6C200, bottom: 0xE6C200 }};
        const PerlinNoise = new (function() { this.p=new Uint8Array(512);this.permutation=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];for(let i=0;i<256;i++)this.p[256+i]=this.p[i]=this.permutation[i];this.fade=function(t){return t*t*t*(t*(t*6-15)+10)};this.lerp=function(t,a,b){return a+t*(b-a)};this.grad=function(h,x,y,z){let H=h&15,u=H<8?x:y,v=H<4?y:H==12||H==14?x:z;return((H&1)==0?u:-u)+((H&2)==0?v:-v)};this.noise=function(x,y,z){let X=Math.floor(x)&255,Y=Math.floor(y)&255,Z=Math.floor(z)&255;x-=Math.floor(x);y-=Math.floor(y);z-=Math.floor(z);let u=this.fade(x),v=this.fade(y),w=this.fade(z),A=this.p[X]+Y,AA=this.p[A]+Z,AB=this.p[A+1]+Z,B=this.p[X+1]+Y,BA=this.p[B]+Z,BB=this.p[B+1]+Z;return this.lerp(w,this.lerp(v,this.lerp(u,this.grad(this.p[AA],x,y,z),this.grad(this.p[BA],x-1,y,z)),this.lerp(u,this.grad(this.p[AB],x,y-1,z),this.grad(this.p[BB],x-1,y-1,z))),this.lerp(v,this.lerp(u,this.grad(this.p[AA+1],x,y,z-1),this.grad(this.p[BA+1],x-1,y,z-1)),this.lerp(u,this.grad(this.p[AB+1],x,y-1,z-1),this.grad(this.p[BB+1],x-1,y-1,z-1))))}})();

        const SLOGAN_POINTS_INCREASE = 20;
        const RELEASE_SCORE_THRESHOLD = 500;
        const SLOGAN_COOLDOWN = 1.5;
        const SOUND_WAVE_PARTICLE_COUNT = 50;
        const SLOGAN_POLICE_RADIUS = 18.0;

        let scene, camera, renderer, controls; let world = {}; let material;
        let playerVelocity = new THREE.Vector3(); let playerOnGround = false;
        let clock = new THREE.Clock(); let keys = {}; let isSprinting = false;
        let sprintMultiplier = SPRINT_MULTIPLIER_DEFAULT; let targetFov; let originalFov;
        let windLinesMesh = null; let chunksToGenerate = []; let chunksToRemove = [];
        const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2();
        let activeParticles = []; let gasClouds = [];
        let gameState = 'MENU';
        const BASE_CITY_Y = Math.floor(CHUNK_HEIGHT / 4);
        let menuCameraAnimation = { active: true, initialPosition: new THREE.Vector3(CHUNK_SIZE / 2, BASE_CITY_Y + 20, CHUNK_SIZE * 1.5), lookAtTarget: new THREE.Vector3(CHUNK_SIZE / 2, BASE_CITY_Y + 3, CHUNK_SIZE / 2) };
        let policeEntities = []; let projectiles = []; let nextEntityId = 0;
        let playerHealth = MAX_HEALTH; let playerStamina = MAX_STAMINA; let lastDamageTime = -Infinity;
        let isMobile = false;
        let joystickActive = false; let joystickStartX = 0; let joystickStartY = 0; let joystickDeltaX = 0; let joystickDeltaY = 0; let joystickMagnitude = 0; let joystickCurrentTouchId = null;
        const joystickMaxDistance = 40;
        let lookActive = false; let lookStartX = 0; let lookStartY = 0; let lookCurrentTouchId = null;
        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        const PI_2 = Math.PI / 2;
        let sloganScore = 0;
        let lastSloganTime = -Infinity;
        let releaseTriggered = false;
        let playerHandMesh, megaphoneMesh;
        let isAnimatingMegaphone = false;
        let megaphoneAnimationTime = 0;

        const engelleyici = document.getElementById('engelleyici'); const menuArayuzu = document.getElementById('menuArayuzu'); const olumEkrani = document.getElementById('olumEkrani'); const olumMesaji = document.getElementById('olumMesaji'); const yenidenBaslatButonu = document.getElementById('yenidenBaslatButonu'); const baslatButonu = document.getElementById('baslatButonu'); const ayarlarButonu = document.getElementById('ayarlarButonu'); const ayarlarIcerigi = document.getElementById('ayarlarIcerigi');
        const bildirimUI = document.getElementById('bildirim'); const kosmaKaydirici = document.getElementById('kosmaKaydirici'); const kosmaHiziDegeriUI = document.getElementById('kosmaHiziDegeri'); const canCubuguIc = document.getElementById('canCubuguIc'); const dayaniklilikCubuguIc = document.getElementById('dayaniklilikCubuguIc'); const hasarKaplamasi = document.getElementById('hasarKaplamasi'); const biberGaziKaplamasi = document.getElementById('biberGaziKaplamasi');
        const mobilKontroller = document.getElementById('mobilKontroller'); const joystickAlani = document.getElementById('joystickAlani'); const joystickTabani = document.getElementById('joystickTabani'); const joystickCubugu = document.getElementById('joystickCubugu'); const kosuButonu = document.getElementById('kosuButonu');
        const ziplamaButonu = document.getElementById('ziplamaButonu');
        const yonlendirmeUyarisi = document.getElementById('yonlendirmeUyarisi');
        const oyunAlaniCanvas = document.getElementById('oyunAlani');
        const sloganSeviyeKapsayici = document.getElementById('sloganSeviyeKapsayici');
        const seviyeCubuguIc = document.getElementById('seviyeCubuguIc');
        const sloganPuanText = document.getElementById('sloganPuanText');
        const kalanPuanText = document.getElementById('kalanPuanText');
        const sloganAtButonu = document.getElementById('sloganAtButonu');
        const basariEkrani = document.getElementById('basariEkrani');
        const anaMenuyeDonButonu = document.getElementById('anaMenuyeDonButonu');

        const gazFirlatmaSesi = document.getElementById('gazFirlatmaSesi'); const gazTislamaSesi = document.getElementById('gazTislamaSesi'); const silahAtesSesi = document.getElementById('silahAtesSesi'); const mermiCarpmaSesi = document.getElementById('mermiCarpmaSesi'); const mermiViziltiSesi = document.getElementById('mermiViziltiSesi'); const oyuncuHasarSesi = document.getElementById('oyuncuHasarSesi'); const polisHasarSesi = document.getElementById('polisHasarSesi'); const olumSesi = document.getElementById('olumSesi');
        const sloganSesi = document.getElementById('sloganSesi');
        const basariSesi = document.getElementById('basariSesi');

        const policeMaterials = { body: new THREE.MeshStandardMaterial({ color: 0x203060, roughness: 0.8, name: 'police_body' }), vest: new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.7, name: 'police_vest' }), helmet: new THREE.MeshStandardMaterial({ color: 0x151515, roughness: 0.6, name: 'police_helmet' }), skin: new THREE.MeshStandardMaterial({ color: 0xffdba1, roughness: 0.8, name: 'police_skin' }) };
        const projectileMaterials = { [PROJECTILE_TYPES.GAS_CAPSULE]: new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.6, roughness: 0.5 }), [PROJECTILE_TYPES.POLICE_BULLET]: new THREE.MeshBasicMaterial({ color: 0x000000 }) };
        const gasCloudMaterial = new THREE.PointsMaterial({ color: 0xb0b0b0, size: 0.3, transparent: true, opacity: 0.5, sizeAttenuation: true, depthWrite: false, blending: THREE.NormalBlending });
        const soundWaveMaterial = new THREE.PointsMaterial({ color: 0xeeeeff, size: 0.15, transparent: true, opacity: 0.7, sizeAttenuation: true, depthWrite: false, blending: THREE.AdditiveBlending });

        function detectMobile() {
            isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
            mobilKontroller.style.display = isMobile ? 'block' : 'none';
        }
        function checkOrientation() {
            if (isMobile) {
                yonlendirmeUyarisi.style.display = window.innerHeight > window.innerWidth ? 'flex' : 'none';
            } else {
                yonlendirmeUyarisi.style.display = 'none';
            }
        }

        function init() {
             try {
                 detectMobile(); checkOrientation();
                 scene = new THREE.Scene(); scene.background = new THREE.Color(0x6699CC); scene.fog = new THREE.Fog(0x6699CC, RENDER_DISTANCE * CHUNK_SIZE * 0.4, RENDER_DISTANCE * CHUNK_SIZE * 1.0);
                 camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, RENDER_DISTANCE * CHUNK_SIZE * 1.1); originalFov = camera.fov; targetFov = originalFov;

                 if (!oyunAlaniCanvas) {
                    throw new Error("Oyun alanı için <canvas id='oyunAlani'> elementi bulunamadı!");
                 }

                 renderer = new THREE.WebGLRenderer({ canvas: oyunAlaniCanvas, antialias: false }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(window.devicePixelRatio); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                 scene.add(new THREE.HemisphereLight(0xaaaaaa, 0x444444, 0.8));
                 const dL = new THREE.DirectionalLight(0xffffff, 1.2);
                 dL.position.set(40, 60, 25);
                 dL.castShadow = true;
                 dL.shadow.mapSize.width = 1024; dL.shadow.mapSize.height = 1024;
                 dL.shadow.camera.near = 10; dL.shadow.camera.far = 150;
                 const shadowCamSize = RENDER_DISTANCE * CHUNK_SIZE * 0.7;
                 dL.shadow.camera.left = -shadowCamSize; dL.shadow.camera.right = shadowCamSize;
                 dL.shadow.camera.top = shadowCamSize; dL.shadow.camera.bottom = -shadowCamSize;
                 dL.shadow.bias = -0.002;
                 scene.add(dL);

                 material = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.9, metalness: 0.05 });

                 const handGeo = new THREE.BoxGeometry(0.1, 0.2, 0.1);
                 const handMat = new THREE.MeshBasicMaterial({ color: 0xffdba1, depthTest: false, depthWrite: false });
                 playerHandMesh = new THREE.Mesh(handGeo, handMat);
                 playerHandMesh.position.set(0.3, -0.3, -0.5);
                 playerHandMesh.renderOrder = 999;
                 camera.add(playerHandMesh);

                 const megaphoneGeo = new THREE.ConeGeometry(0.1, 0.3, 8);
                 const megaphoneMat = new THREE.MeshBasicMaterial({ color: 0xaaaaaa, depthTest: false, depthWrite: false });
                 megaphoneMesh = new THREE.Mesh(megaphoneGeo, megaphoneMat);
                 megaphoneMesh.position.set(0.35, -0.25, -0.7);
                 megaphoneMesh.rotation.x = Math.PI / 2;
                 megaphoneMesh.rotation.z = -Math.PI / 12;
                 megaphoneMesh.renderOrder = 999;
                 camera.add(megaphoneMesh);

                 isAnimatingMegaphone = false;
                 megaphoneAnimationTime = 0;

                 setupControls();
                 setupMobileControls();
                 setupMenu();
                 setupSprintUI();
                 setupSloganUI();
                 createWindLines();

                 yenidenBaslatButonu.addEventListener('click', restartGame);
                 anaMenuyeDonButonu.addEventListener('click', showMenu);
                 window.addEventListener('resize', ()=>{ onWindowResize(); checkOrientation(); });
                 window.addEventListener('orientationchange', checkOrientation);
                 document.addEventListener('keydown', handleKeyDown);
                 document.addEventListener('keyup', (event) => { keys[event.code] = false; handleKeyUp(event); });
                 document.body.addEventListener('mousedown', handleMouseDown);

                 showMenu();
                 preloadInitialChunks();
                 animate();

             } catch (error) {
                 console.error("Başlatma sırasında kritik hata:", error);
                 if(engelleyici) engelleyici.style.display = 'flex';
                 if(menuArayuzu) menuArayuzu.innerHTML = `<h1>HATA!</h1><p>Oyun başlatılamadı.</p><p style="font-size:0.8em; color: #ffaaaa;">Detaylar için konsolu (F12) kontrol edin.</p><p style="font-size:0.7em; color:#aaa;">${error.message}</p>`;
                 if(olumEkrani) olumEkrani.style.display = 'none';
                 if(basariEkrani) basariEkrani.style.display = 'none';
                 const sBC = document.querySelector('.durum_cubuklari_kapsayici');
                 if (sBC) sBC.style.display = 'none';
                 if(sloganSeviyeKapsayici) sloganSeviyeKapsayici.style.display = 'none';
                 if(yonlendirmeUyarisi) yonlendirmeUyarisi.style.display = 'none';
                 if (renderer) renderer.dispose();
             }
        }

        function preloadInitialChunks() {
            const preloadRadius = 2;
            let generatedCount = 0;
            for (let x = -preloadRadius; x <= preloadRadius; x++) {
                for (let z = -preloadRadius; z <= preloadRadius; z++) {
                    if (!world[getChunkKey(x, z)]) {
                        generateChunkData(x, z);
                        generatedCount++;
                    }
                }
            }
            updateWorldChunks();
            processChunkMeshUpdates();
        }

        function setupMenu() {
            baslatButonu.addEventListener('click', startGame);
            ayarlarButonu.addEventListener('click', toggleSettings);
        }

        function startGame() {
             if (isMobile && window.innerHeight > window.innerWidth) {
                 checkOrientation();
                 return;
             }

             const resuming = gameState === 'PAUSED';
             gameState = 'PLAYING';
             olumEkrani.style.display = 'none';
             basariEkrani.style.display = 'none';
             menuCameraAnimation.active = false;
             engelleyici.style.display = 'none';
             const sBC = document.querySelector('.durum_cubuklari_kapsayici');
             if (sBC) sBC.style.display = 'flex';
             if (sloganSeviyeKapsayici) sloganSeviyeKapsayici.style.display = 'flex';
             bildirimUI.style.display = 'none';

             if (!resuming) {
                 resetGameSate();
             } else {
                 updateSloganUI();
             }

             camera.fov = originalFov;
             camera.updateProjectionMatrix();
             targetFov = originalFov;
             keys = {};
             isSprinting = false;

             joystickActive = false;
             joystickDeltaX = 0; joystickDeltaY = 0; joystickMagnitude = 0;
             if(joystickCubugu) joystickCubugu.style.transform = `translate(-50%, -50%) translate(0px, 0px)`;
             lookActive = false;
             lookCurrentTouchId = null;
             joystickCurrentTouchId = null;

             if (!isMobile && controls && !controls.isLocked) {
                 try {
                     controls.lock();
                 } catch(e) {
                     showNotification("Oyuna tıklayarak kontrolü etkinleştirin.");
                 }
             }
        }

        function resetGameSate() {
             let startY = getSurfaceHeight(CHUNK_SIZE/2, CHUNK_SIZE/2) + PLAYER_HEIGHT/2 + 0.1;
             let tries = 0;
             while(getBlock(CHUNK_SIZE/2, Math.floor(startY - PLAYER_HEIGHT/2 + 0.1), CHUNK_SIZE/2) !== BLOCK_TYPES.AIR && tries < 10){
                 startY += 1;
                 tries++;
             }
             if(startY >= CHUNK_HEIGHT - 1) startY = BASE_CITY_Y + PLAYER_HEIGHT/2 + 2;
             const startPos = new THREE.Vector3(CHUNK_SIZE/2 + (Math.random()-0.5)*2, startY, CHUNK_SIZE/2 + (Math.random()-0.5)*2);
             camera.position.copy(startPos);

             euler.set(0, 0, 0);
             camera.quaternion.setFromEuler(euler);

             if(controls && controls.getObject()){
                 controls.getObject().position.copy(startPos);
             }

             playerVelocity.set(0, 0, 0);
             playerHealth = MAX_HEALTH;
             playerStamina = MAX_STAMINA;
             lastDamageTime = -Infinity;

             sloganScore = 0;
             lastSloganTime = -Infinity;
             releaseTriggered = false;

             policeEntities.forEach(p => { if(p.mesh) scene.remove(p.mesh); });
             policeEntities = [];
             projectiles.forEach(p => { if(p.mesh) scene.remove(p.mesh); });
             projectiles = [];
             activeParticles.forEach(p => { if(p){ scene.remove(p); p.geometry?.dispose(); p.material?.dispose(); } });
             activeParticles = [];
             gasClouds.forEach(c => { if(c.mesh) scene.remove(c.mesh); });
             gasClouds = [];

             updateHealthStaminaUI();
             updateSloganUI();
             stopPepperSprayScreenEffect();
             hasarKaplamasi.style.display = 'none';
        }

        function showMenu() {
             gameState = 'MENU';
             menuCameraAnimation.active = true;
             olumEkrani.style.display = 'none';
             basariEkrani.style.display = 'none';
             engelleyici.style.display = 'flex';
             const sBC = document.querySelector('.durum_cubuklari_kapsayici');
             if (sBC) sBC.style.display = 'none';
             if (sloganSeviyeKapsayici) sloganSeviyeKapsayici.style.display = 'none';

             bildirimUI.style.display = 'none';
             ayarlarIcerigi.style.display = 'none';

             if (controls && controls.isLocked) {
                 controls.unlock();
             }
             isSprinting = false;
             if (windLinesMesh) windLinesMesh.visible = false;

             camera.position.copy(menuCameraAnimation.initialPosition);
             camera.lookAt(menuCameraAnimation.lookAtTarget);
             camera.fov = originalFov;
             camera.updateProjectionMatrix();

             checkOrientation();
        }

        function toggleSettings() {
            ayarlarIcerigi.style.display = ayarlarIcerigi.style.display === 'none' ? 'block' : 'none';
        }

        function pauseGame() {
             if(gameState !== 'PLAYING') return;

             gameState = 'PAUSED';
             olumEkrani.style.display = 'none';
             basariEkrani.style.display = 'none';
             engelleyici.style.display = 'flex';

             const sBC = document.querySelector('.durum_cubuklari_kapsayici');
             if(sBC) sBC.style.display = 'none';
             if (sloganSeviyeKapsayici) sloganSeviyeKapsayici.style.display = 'none';
             bildirimUI.style.display = 'none';
             ayarlarIcerigi.style.display = 'none';

             isSprinting = false;
             if(windLinesMesh) windLinesMesh.visible = false;
             targetFov = originalFov;
             camera.fov = originalFov;
             camera.updateProjectionMatrix();

             if(controls && controls.isLocked){
                 controls.unlock();
             }
             joystickActive = false;
             joystickDeltaX = 0; joystickDeltaY = 0; joystickMagnitude = 0;
             if(joystickCubugu) joystickCubugu.style.transform = `translate(-50%, -50%) translate(0px, 0px)`;
             lookActive = false;
        }

        function restartGame() {
            showMenu();
            resetGameSate();
        }

        function setupControls() {
            if(isMobile || typeof PointerLockControls === 'undefined') return;

             try {
                controls = new PointerLockControls(camera, document.body);

                const blockerElement = document.getElementById('engelleyici');
                const menuElement = document.getElementById('menuArayuzu');
                const deathScreenElement = document.getElementById('olumEkrani');
                const successScreenElement = document.getElementById('basariEkrani');

                document.body.addEventListener('click', (event) => {
                    if (gameState === 'PLAYING' && controls && !controls.isLocked) {
                         if (!menuElement.contains(event.target) &&
                             !deathScreenElement.contains(event.target) &&
                             !successScreenElement.contains(event.target) &&
                             blockerElement.style.display === 'none')
                          {
                            try {
                                controls.lock();
                            } catch(err){
                                showNotification("Kontrolü etkinleştirmek için tekrar tıklayın.");
                            }
                         }
                    }
                });

                controls.addEventListener('lock', () => {
                    if (gameState === 'PLAYING') {
                        blockerElement.style.display = 'none';
                        const sBC = document.querySelector('.durum_cubuklari_kapsayici');
                        if(sBC) sBC.style.display = 'flex';
                        if (sloganSeviyeKapsayici) sloganSeviyeKapsayici.style.display = 'flex';
                        keys = {};
                    } else {
                        controls.unlock();
                    }
                });

                controls.addEventListener('unlock', () => {
                    if (gameState === 'PLAYING') {
                        pauseGame();
                    }
                });

                scene.add(controls.getObject());

             } catch(e) {
                 console.error("PointerLockControls yüklenemedi:", e);
                 controls = null;
                 showNotification("Fare kontrolü yüklenemedi.");
             }
        }

        function setupMobileControls() {
            if (!isMobile) return;

            joystickAlani.addEventListener('touchstart', handleJoystickStart, { passive: false });
            joystickAlani.addEventListener('touchmove', handleJoystickMove, { passive: false });
            joystickAlani.addEventListener('touchend', handleJoystickEnd, { passive: false });
            joystickAlani.addEventListener('touchcancel', handleJoystickEnd, { passive: false });

            kosuButonu.addEventListener('touchstart', handleSprintStart, { passive: false });
            kosuButonu.addEventListener('touchend', handleSprintEnd, { passive: false });
            kosuButonu.addEventListener('touchcancel', handleSprintEnd, { passive: false });

            ziplamaButonu.addEventListener('touchstart', handleJumpPress, { passive: false });

            sloganAtButonu.addEventListener('touchstart', (e) => {
                e.preventDefault();
                performSloganChant();
            }, { passive: false });

            document.body.addEventListener('touchstart', handleLookStart, { passive: false });
            document.body.addEventListener('touchmove', handleLookMove, { passive: false });
            document.body.addEventListener('touchend', handleLookEnd, { passive: false });
            document.body.addEventListener('touchcancel', handleLookEnd, { passive: false });
        }

        function handleJoystickStart(e) {
            if (gameState !== 'PLAYING') return;
            e.preventDefault();
            if (joystickCurrentTouchId === null && e.changedTouches.length > 0) {
                const touch = e.changedTouches[0];
                if(lookCurrentTouchId === touch.identifier) return;
                const targetElement = touch.target;
                 if (kosuButonu.contains(targetElement) || ziplamaButonu.contains(targetElement) || sloganAtButonu.contains(targetElement)) {
                    return;
                 }

                joystickCurrentTouchId = touch.identifier;
                joystickActive = true;
                const rect = joystickAlani.getBoundingClientRect();
                joystickStartX = rect.left + rect.width / 2;
                joystickStartY = rect.top + rect.height / 2;
                handleJoystickMove(e);
            }
        }
        function handleJoystickMove(e) {
            if (!joystickActive || gameState !== 'PLAYING') return;
            let touch = null;
            for(let i=0; i < e.changedTouches.length; i++){
                if(e.changedTouches[i].identifier === joystickCurrentTouchId){
                    touch = e.changedTouches[i];
                    break;
                }
            }
            if(!touch) return;

            e.preventDefault();

            const currentX = touch.clientX;
            const currentY = touch.clientY;
            let deltaXRaw = currentX - joystickStartX;
            let deltaYRaw = currentY - joystickStartY;
            const distance = Math.sqrt(deltaXRaw*deltaXRaw + deltaYRaw*deltaYRaw);

            let clampedX = deltaXRaw;
            let clampedY = deltaYRaw;

            if (distance > joystickMaxDistance) {
                clampedX = (deltaXRaw / distance) * joystickMaxDistance;
                clampedY = (deltaYRaw / distance) * joystickMaxDistance;
            }

            joystickDeltaX = clampedX / joystickMaxDistance;
            joystickDeltaY = clampedY / joystickMaxDistance;
            joystickMagnitude = Math.min(1, distance / joystickMaxDistance);

            if(joystickCubugu) {
                joystickCubugu.style.transform = `translate(-50%, -50%) translate(${clampedX}px, ${clampedY}px)`;
            }
        }
        function handleJoystickEnd(e) {
            if (!joystickActive || gameState !== 'PLAYING') return;
            let touchEnded = false;
            for(let i=0; i < e.changedTouches.length; i++){
                if(e.changedTouches[i].identifier === joystickCurrentTouchId){
                    touchEnded = true;
                    break;
                }
            }

            if(touchEnded){
                e.preventDefault();
                joystickActive = false;
                joystickDeltaX = 0;
                joystickDeltaY = 0;
                joystickMagnitude = 0;
                joystickCurrentTouchId = null;
                if(joystickCubugu) {
                    joystickCubugu.style.transform = `translate(-50%, -50%) translate(0px, 0px)`;
                }
            }
        }
        function handleSprintStart(e) {
            if(gameState !== 'PLAYING') return;
            e.preventDefault();
            if (playerStamina > 0) {
                isSprinting = true;
                targetFov = originalFov + SPRINT_FOV_INCREASE;
            }
        }
        function handleSprintEnd(e) {
             if (e.type === 'touchcancel' || e.type === 'touchend') {
                if(gameState !== 'PLAYING') return;
                e.preventDefault();
                isSprinting = false;
                targetFov = originalFov;
             }
        }
        function handleJumpPress(e) {
            if (gameState !== 'PLAYING') return;
            e.preventDefault();
            if (playerOnGround) {
                playerVelocity.y = JUMP_VELOCITY;
                playerOnGround = false;
            }
        }
        function handleLookStart(e){
            if (gameState !== 'PLAYING' || !isMobile || lookActive) return;
            const touch = e.changedTouches[0];
            if (!touch) return;
            const targetElement = touch.target;
             if (joystickAlani.contains(targetElement) || kosuButonu.contains(targetElement) || ziplamaButonu.contains(targetElement) || sloganAtButonu.contains(targetElement)) {
                return;
             }
             if (joystickCurrentTouchId !== null && touch.identifier === joystickCurrentTouchId) {
                return;
             }
            if (lookCurrentTouchId === null) {
                lookCurrentTouchId = touch.identifier;
                lookActive = true;
                lookStartX = touch.clientX;
                lookStartY = touch.clientY;
                e.preventDefault();
            }
        }
        function handleLookMove(e){
            if (!lookActive || gameState !== 'PLAYING') return;
            let touch = null;
            for(let i=0; i<e.changedTouches.length; i++){
                if(e.changedTouches[i].identifier === lookCurrentTouchId){
                    touch = e.changedTouches[i];
                    break;
                }
            }
            if(!touch) return;
            e.preventDefault();
            const currentX = touch.clientX;
            const currentY = touch.clientY;
            const deltaX = currentX - lookStartX;
            const deltaY = currentY - lookStartY;
            euler.setFromQuaternion(camera.quaternion);
            euler.y -= deltaX * LOOK_SENSITIVITY;
            euler.x -= deltaY * LOOK_SENSITIVITY;
            euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
            camera.quaternion.setFromEuler(euler);
            lookStartX = currentX;
            lookStartY = currentY;
        }
        function handleLookEnd(e){
            if (!lookActive || gameState !== 'PLAYING') return;
            let touchEnded = false;
            for(let i=0; i<e.changedTouches.length; i++){
                if(e.changedTouches[i].identifier === lookCurrentTouchId){
                    touchEnded = true;
                    break;
                }
            }
            if(touchEnded){
                e.preventDefault();
                lookActive = false;
                lookCurrentTouchId = null;
            }
        }

        function handleKeyDown(event) {
            keys[event.code] = true;
            if(event.code === 'Escape'){
                if(gameState === 'PLAYING'){
                    pauseGame();
                } else if(gameState === 'PAUSED'){
                    startGame();
                }
                return;
            }

            if(isMobile || gameState !== 'PLAYING' || playerHealth <= 0) {
                return;
            }
            if(event.code === 'ShiftLeft' || event.code === 'ShiftRight'){
                if(!isSprinting && playerStamina > 0 && playerOnGround){
                    isSprinting = true;
                    targetFov = originalFov + SPRINT_FOV_INCREASE;
                }
            }
        }
        function handleKeyUp(event) {
            keys[event.code] = false;
            if(isMobile) return;
            if(event.code === 'ShiftLeft' || event.code === 'ShiftRight'){
                if(!keys['ShiftLeft'] && !keys['ShiftRight']){
                    isSprinting = false;
                    targetFov = originalFov;
                }
            }
        }
        function handleMouseDown(event) {
            if (!isMobile && gameState === 'PLAYING' && controls && controls.isLocked && event.button === 0) {
                performSloganChant();
            }
        }

        function setupSloganUI() {
            updateSloganUI();
        }

        function updateSloganUI() {
            if (!seviyeCubuguIc || !sloganPuanText || !kalanPuanText) return;

            const score = Math.max(0, sloganScore);
            const targetScore = RELEASE_SCORE_THRESHOLD;
            const percentage = Math.min(100, (score / targetScore) * 100);
            const remaining = Math.max(0, targetScore - score);

            seviyeCubuguIc.style.width = `${percentage}%`;
            sloganPuanText.textContent = `Slogan Puanı: ${score}`;
            kalanPuanText.textContent = `Serbest kalmasına kalan: ${remaining}`;
        }

        function isPlayerNearPolice() {
            if (gameState !== 'PLAYING' || !camera || policeEntities.length === 0) {
                return false;
            }
            const playerPos = camera.position;
            const radiusSq = SLOGAN_POLICE_RADIUS * SLOGAN_POLICE_RADIUS;
            for (const police of policeEntities) {
                if (police && police.position && police.health > 0) {
                    if (playerPos.distanceToSquared(police.position) < radiusSq) {
                        return true;
                    }
                }
            }
            return false;
        }

        function performSloganChant() {
            const now = clock.getElapsedTime();
            if (gameState !== 'PLAYING' || playerHealth <= 0 || releaseTriggered) {
                return;
            }

            const nearPolice = isPlayerNearPolice();

            if (!nearPolice) {
                showNotification("Yakında polis yok!");
                return;
            }

            if (now < lastSloganTime + SLOGAN_COOLDOWN) {
                return;
            }

            lastSloganTime = now;

            playSound(sloganSesi, 0.8);
            createSoundWaveParticles(camera.position);
            sloganScore += SLOGAN_POINTS_INCREASE;
            sloganScore = Math.min(sloganScore, RELEASE_SCORE_THRESHOLD);
            updateSloganUI();

            isAnimatingMegaphone = true;
            megaphoneAnimationTime = 0;

            if (!releaseTriggered && sloganScore >= RELEASE_SCORE_THRESHOLD) {
                releaseTriggered = true;
                triggerSuccessSequence();
            }
        }

        function createSoundWaveParticles(originPosition) {
            const count = SOUND_WAVE_PARTICLE_COUNT;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const velocities = new Float32Array(count * 3);
            const lifetimes = new Float32Array(count);
            const initialLifetimes = new Float32Array(count);
            const maxLifetime = 0.8;
            const initialSpeed = 3.0;
            const spreadFactor = 0.2;
             const forward = new THREE.Vector3();
             camera.getWorldDirection(forward);
             const emitOrigin = originPosition.clone().addScaledVector(forward, 0.5);
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                positions[i3 + 0] = emitOrigin.x;
                positions[i3 + 1] = emitOrigin.y;
                positions[i3 + 2] = emitOrigin.z;
                 const phi = Math.random() * Math.PI * 2;
                 const costheta = Math.random() * 1.6 - 0.8;
                 const sintheta = Math.sqrt(1 - costheta * costheta);
                 let vx = sintheta * Math.cos(phi);
                 let vy = costheta;
                 let vz = sintheta * Math.sin(phi);
                 vx += (Math.random() - 0.5) * spreadFactor;
                 vy += (Math.random() - 0.5) * spreadFactor;
                 vz += (Math.random() - 0.5) * spreadFactor;
                const speed = initialSpeed * (0.8 + Math.random() * 0.4);
                velocities[i3 + 0] = vx * speed;
                velocities[i3 + 1] = vy * speed;
                velocities[i3 + 2] = vz * speed;
                const lifetime = maxLifetime * (0.7 + Math.random() * 0.3);
                lifetimes[i] = lifetime;
                initialLifetimes[i] = lifetime;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));
            geometry.setAttribute('initialLifetime', new THREE.BufferAttribute(initialLifetimes, 1));
            const points = new THREE.Points(geometry, soundWaveMaterial);
            points.userData = { type: 'sound_wave', startTime: clock.elapsedTime };
            scene.add(points);
            activeParticles.push(points);
        }

        function triggerSuccessSequence() {
            if (gameState !== 'PLAYING') return;

            gameState = 'SUCCESS';
            playSound(basariSesi);

            const sBC = document.querySelector('.durum_cubuklari_kapsayici');
            if (sBC) sBC.style.display = 'none';
            if (sloganSeviyeKapsayici) sloganSeviyeKapsayici.style.display = 'none';
            if (mobilKontroller) mobilKontroller.style.display = 'none';

            basariEkrani.style.display = 'flex';

            isSprinting = false;
            if (windLinesMesh) windLinesMesh.visible = false;
            playerVelocity.set(0,0,0);
            keys = {};

            if (controls && controls.isLocked) {
                controls.unlock();
            }
             joystickActive = false;
             lookActive = false;
        }

        const MEGAPHONE_ANIM_DURATION = 0.3;
        const MEGAPHONE_ANIM_ANGLE = Math.PI / 10;
        const MEGAPHONE_ANIM_FORWARD = 0.05;

        function animateMegaphone(deltaTime) {
            if (!isAnimatingMegaphone || !playerHandMesh || !megaphoneMesh) return;

            megaphoneAnimationTime += deltaTime;
            const progress = Math.min(1.0, megaphoneAnimationTime / MEGAPHONE_ANIM_DURATION);
            const easedProgress = 1 - Math.pow(1 - progress, 3); // Ease out cubic

            const angleOffset = Math.sin(progress * Math.PI) * MEGAPHONE_ANIM_ANGLE;
            const forwardOffset = Math.sin(progress * Math.PI) * MEGAPHONE_ANIM_FORWARD;

            megaphoneMesh.rotation.x = Math.PI / 2 - angleOffset;
            megaphoneMesh.position.z = -0.7 + forwardOffset;
            playerHandMesh.rotation.x = -angleOffset * 0.5;
             playerHandMesh.position.z = -0.5 + forwardOffset * 0.5;


            if (progress >= 1.0) {
                isAnimatingMegaphone = false;
                megaphoneAnimationTime = 0;
                megaphoneMesh.rotation.x = Math.PI / 2;
                megaphoneMesh.position.z = -0.7;
                playerHandMesh.rotation.x = 0;
                playerHandMesh.position.z = -0.5;

            }
        }

        function worldToChunkCoords(x, y, z){ return { chunkX: Math.floor(x / CHUNK_SIZE), chunkZ: Math.floor(z / CHUNK_SIZE), localX: THREE.MathUtils.euclideanModulo(x, CHUNK_SIZE), localY: Math.floor(y), localZ: THREE.MathUtils.euclideanModulo(z, CHUNK_SIZE) }; }
        function getChunkKey(chunkX, chunkZ){ return `${chunkX},${chunkZ}`; }
        function getBlockIndex(localX, localY, localZ){ if(localX < 0 || localX >= CHUNK_SIZE || localY < 0 || localY >= CHUNK_HEIGHT || localZ < 0 || localZ >= CHUNK_SIZE) { return -1; } return localY * CHUNK_SIZE * CHUNK_SIZE + localZ * CHUNK_SIZE + localX; }
        function getBlock(worldX, worldY, worldZ){ const { chunkX, chunkZ, localX, localY, localZ } = worldToChunkCoords(worldX, worldY, worldZ); const key = getChunkKey(chunkX, chunkZ); const chunk = world[key]; if(!chunk || !chunk.blocks || localY < 0 || localY >= CHUNK_HEIGHT) { return localY < BASE_CITY_Y - 5 ? BLOCK_TYPES.BUILDING_WALL_GRAY : BLOCK_TYPES.AIR; } const index = getBlockIndex(localX, localY, localZ); return index === -1 ? BLOCK_TYPES.AIR : chunk.blocks[index]; }
        function setBlock(worldX, worldY, worldZ, blockType){ const { chunkX, chunkZ, localX, localY, localZ } = worldToChunkCoords(worldX, worldY, worldZ); const key = getChunkKey(chunkX, chunkZ); const chunk = world[key]; if(!chunk || !chunk.blocks || localY < 0 || localY >= CHUNK_HEIGHT) { return; } const index = getBlockIndex(localX, localY, localZ); if(index === -1) return; if(chunk.blocks[index] !== blockType){ chunk.blocks[index] = blockType; scheduleChunkMeshUpdate(chunkX, chunkZ); if(localX === 0) scheduleChunkMeshUpdate(chunkX - 1, chunkZ); if(localX === CHUNK_SIZE - 1) scheduleChunkMeshUpdate(chunkX + 1, chunkZ); if(localZ === 0) scheduleChunkMeshUpdate(chunkX, chunkZ - 1); if(localZ === CHUNK_SIZE - 1) scheduleChunkMeshUpdate(chunkX, chunkZ + 1); } }
        const scheduledMeshUpdates = new Set();
        function scheduleChunkMeshUpdate(chunkX, chunkZ){ const key = getChunkKey(chunkX, chunkZ); if(world[key] && !scheduledMeshUpdates.has(key)) { scheduledMeshUpdates.add(key); } }
        function processChunkMeshUpdates(){ if(scheduledMeshUpdates.size === 0) return; const updatesToProcess = Array.from(scheduledMeshUpdates); scheduledMeshUpdates.clear(); updatesToProcess.forEach(key => { const [chunkX, chunkZ] = key.split(',').map(Number); if (world[key]) { generateChunkMesh(chunkX, chunkZ); } }); }
        function getBlockLocalOrNeighbor(chunkX, chunkZ, localX, localY, localZ){ if(localY < 0 || localY >= CHUNK_HEIGHT) return BLOCK_TYPES.AIR; let targetChunkX = chunkX; let targetChunkZ = chunkZ; let targetLocalX = localX; let targetLocalZ = localZ; if(localX < 0) { targetChunkX--; targetLocalX = CHUNK_SIZE - 1; } else if(localX >= CHUNK_SIZE) { targetChunkX++; targetLocalX = 0; } if(localZ < 0) { targetChunkZ--; targetLocalZ = CHUNK_SIZE - 1; } else if(localZ >= CHUNK_SIZE) { targetChunkZ++; targetLocalZ = 0; } const key = getChunkKey(targetChunkX, targetChunkZ); const chunk = world[key]; if(!chunk || !chunk.blocks) { return localY < BASE_CITY_Y ? BLOCK_TYPES.BUILDING_WALL_GRAY : BLOCK_TYPES.AIR; } const index = getBlockIndex(targetLocalX, localY, targetLocalZ); return index === -1 ? BLOCK_TYPES.AIR : chunk.blocks[index]; }
        function generateBuilding(baseX, baseY, baseZ, width, depth, height, wallType = BLOCK_TYPES.BUILDING_WALL_GRAY){ for(let y=0; y<height; y++){ for(let x=0; x<width; x++){ for(let z=0; z<depth; z++){ let block = wallType; const worldY = baseY + y; if(y === 0) block = block === BLOCK_TYPES.BUILDING_WALL_BRICK ? BLOCK_TYPES.SIDEWALK : BLOCK_TYPES.BUILDING_WALL_GRAY; if(x === 0 || x === width-1 || z === 0 || z === depth-1){ if((x > 0 && x < width - 1 && z > 0 && z < depth - 1) && y > 0 && y < height -1 && Math.random() < 0.3) block = BLOCK_TYPES.WINDOW; } else { block = BLOCK_TYPES.AIR; } if(y === height-1) block = BLOCK_TYPES.BUILDING_WALL_GRAY; setBlock(baseX+x, worldY, baseZ+z, block); } } } }
        function generateLampPost(baseX, baseY, baseZ){ for(let y=0; y<5; y++) setBlock(baseX, baseY+y, baseZ, BLOCK_TYPES.METAL_FENCE); setBlock(baseX, baseY+5, baseZ, BLOCK_TYPES.LAMP_POST); setBlock(baseX+1, baseY+5, baseZ, BLOCK_TYPES.LAMP_POST); }
        function generateCar(baseX, baseY, baseZ, isPoliceCar = false) { const carWidth=2; const carDepth=4; const carHeight=1; const wheelHeight = 0; const bodyType = isPoliceCar ? BLOCK_TYPES.POLICE_CAR_BODY : (Math.random() < 0.5 ? BLOCK_TYPES.CAR_BODY_WHITE : BLOCK_TYPES.CAR_BODY_BLUE); for(let x=0; x<carWidth; x++){ for(let z=0; z<carDepth; z++){ setBlock(baseX+x, baseY+wheelHeight, baseZ+z, BLOCK_TYPES.CAR_WHEEL); for(let y=1; y<=carHeight; y++){ setBlock(baseX+x, baseY+y, baseZ+z, bodyType); } if(z === 0 && x === 0 && isPoliceCar) setBlock(baseX+x, baseY+carHeight+1, baseZ+z, BLOCK_TYPES.POLICE_CAR_LIGHT_RED); if(z === 0 && x === carWidth-1 && isPoliceCar) setBlock(baseX+x, baseY+carHeight+1, baseZ+z, BLOCK_TYPES.POLICE_CAR_LIGHT_BLUE); } } }
        function generateTree(baseX, baseY, baseZ) { const height = 4 + Math.floor(Math.random() * 3); const radius = 2; for(let y=0; y<height; y++) setBlock(baseX, baseY+y, baseZ, BLOCK_TYPES.TREE_TRUNK); const leafYStart = baseY + height - 2; const leafYEnd = baseY + height + 2; for(let y = leafYStart; y < leafYEnd; y++){ for(let x = -radius; x <= radius; x++){ for(let z = -radius; z <= radius; z++){ const distSq = x*x + z*z; const effectiveRadius = y === leafYEnd - 1 ? radius * 0.6 : radius; if(distSq <= effectiveRadius*effectiveRadius){ if (getBlock(baseX+x, y, baseZ+z) === BLOCK_TYPES.AIR) { setBlock(baseX+x, y, baseZ+z, BLOCK_TYPES.TREE_LEAVES); } } } } } }
        function generatePoliceBarrier(baseX, baseY, baseZ, length = 3, axis = 'x') { for (let i=0; i<length; i++){ const xOff = axis === 'x' ? i : 0; const zOff = axis === 'z' ? i : 0; setBlock(baseX + xOff, baseY, baseZ + zOff, BLOCK_TYPES.POLICE_BARRIER); setBlock(baseX + xOff, baseY + 1, baseZ + zOff, BLOCK_TYPES.METAL_FENCE); } }
        function generateChunkData(chunkX, chunkZ){ const key = getChunkKey(chunkX, chunkZ); if(world[key]) return; const chunk = { blocks: new Uint8Array(CHUNK_SIZE * CHUNK_HEIGHT * CHUNK_SIZE), mesh: null, structuresGenerated: false }; world[key] = chunk; for(let x = 0; x < CHUNK_SIZE; x++){ for(let z = 0; z < CHUNK_SIZE; z++){ const worldX = chunkX * CHUNK_SIZE + x; const worldZ = chunkZ * CHUNK_SIZE + z; const groundNoise = (PerlinNoise.noise(worldX * NOISE_SCALE_GROUND, worldZ * NOISE_SCALE_GROUND, 10) + 1) / 2; const surfaceHeight = BASE_CITY_Y + Math.floor(groundNoise * WORLD_HEIGHT_VARIATION); const roadNoise = (PerlinNoise.noise(worldX * 0.03, worldZ * 0.03, 100) + 1) / 2; const forestNoise = (PerlinNoise.noise(worldX * NOISE_SCALE_FOREST, worldZ * NOISE_SCALE_FOREST, 200) + 1) / 2; let baseBlockType = BLOCK_TYPES.SIDEWALK; let isRoadArea = false; let isParkArea = false; const roadWidth = 4; const sidewalkWidth = 2; const roadInterval = 24; if (Math.abs(worldX % roadInterval) < roadWidth || Math.abs(worldZ % roadInterval) < roadWidth) { isRoadArea = true; if (Math.abs(worldX % roadInterval) >= roadWidth - sidewalkWidth && Math.abs(worldZ % roadInterval) >= roadWidth - sidewalkWidth) { baseBlockType = BLOCK_TYPES.ASPHALT; } else { baseBlockType = BLOCK_TYPES.SIDEWALK; } } else { if (forestNoise > 0.55) { isParkArea = true; baseBlockType = BLOCK_TYPES.PARK_GRASS; } else if (forestNoise > 0.45) { baseBlockType = BLOCK_TYPES.PARK_GRASS; } else { baseBlockType = BLOCK_TYPES.SIDEWALK; } } for(let y = 0; y < CHUNK_HEIGHT; y++){ const blockIndex = getBlockIndex(x, y, z); if (blockIndex === -1) continue; let blockType = BLOCK_TYPES.AIR; if(y < surfaceHeight) { blockType = baseBlockType === BLOCK_TYPES.ASPHALT ? BLOCK_TYPES.ASPHALT : (baseBlockType === BLOCK_TYPES.PARK_GRASS ? BLOCK_TYPES.BUILDING_WALL_BRICK : BLOCK_TYPES.BUILDING_WALL_GRAY); } else if (y === surfaceHeight) { blockType = baseBlockType; } chunk.blocks[blockIndex] = blockType; } const surfaceBlockIndex = getBlockIndex(x, surfaceHeight, z); if(surfaceBlockIndex !== -1) { const surfaceBlock = chunk.blocks[surfaceBlockIndex]; if(surfaceBlock === BLOCK_TYPES.SIDEWALK || surfaceBlock === BLOCK_TYPES.PARK_GRASS){ if(policeEntities.length < MAX_POLICE && Math.random() < POLICE_SPAWN_CHANCE * (isParkArea ? 0.3 : 1.0)){ spawnPolice(new THREE.Vector3(worldX + 0.5, surfaceHeight + PLAYER_HEIGHT/2 + 0.1, worldZ + 0.5)); } } } } } if(!chunk.structuresGenerated){ for(let x = 0; x < CHUNK_SIZE; x++){ for(let z = 0; z < CHUNK_SIZE; z++){ const worldX = chunkX * CHUNK_SIZE + x; const worldZ = chunkZ * CHUNK_SIZE + z; const surfaceY = getSurfaceHeight(worldX, worldZ); if(surfaceY < 0 || surfaceY >= CHUNK_HEIGHT) continue; const blockIndex = getBlockIndex(x, surfaceY, z); if(blockIndex === -1 || blockIndex >= chunk.blocks.length) continue; const blockOnSurface = chunk.blocks[blockIndex]; const forestNoise = (PerlinNoise.noise(worldX * NOISE_SCALE_FOREST, worldZ * NOISE_SCALE_FOREST, 200) + 1) / 2; const isParkArea = forestNoise > 0.55; const isRoad = Math.abs(worldX % 24) < 4 || Math.abs(worldZ % 24) < 4; if (blockOnSurface === BLOCK_TYPES.PARK_GRASS && surfaceY >= BASE_CITY_Y) { const treeChance = isParkArea ? 0.1 : 0.03; if (Math.random() < treeChance && getBlock(worldX, surfaceY+1, worldZ) === BLOCK_TYPES.AIR) { let spaceClear = true; for(let dx = -1; dx <= 1; dx++) { for(let dz = -1; dz <= 1; dz++) { if (getBlock(worldX+dx, surfaceY, worldZ+dz) !== BLOCK_TYPES.PARK_GRASS) { spaceClear = false; break; } } if (!spaceClear) break; } if (spaceClear) { generateTree(worldX, surfaceY + 1, worldZ); } } } else if(blockOnSurface === BLOCK_TYPES.SIDEWALK && surfaceY >= BASE_CITY_Y && !isParkArea){ const buildingNoiseValue = (PerlinNoise.noise(worldX * NOISE_SCALE_BUILDING, worldZ * NOISE_SCALE_BUILDING, 50) + 1) / 2; if(x % 8 === 1 && z % 10 === 1 && buildingNoiseValue > 0.65){ const buildingWidth = 4 + Math.floor(Math.random() * 5); const buildingDepth = 5 + Math.floor(Math.random() * 6); const buildingHeight = 5 + Math.floor(Math.random() * 10); const wallType = Math.random() < 0.6 ? BLOCK_TYPES.BUILDING_WALL_GRAY : BLOCK_TYPES.BUILDING_WALL_BRICK; if(x + buildingWidth < CHUNK_SIZE && z + buildingDepth < CHUNK_SIZE){ let canBuild = true; for(let bx = x - 1; bx < x + buildingWidth + 1; bx++){ for(let bz = z - 1; bz < z + buildingDepth + 1; bz++){ const checkIndex = getBlockIndex(bx, surfaceY, bz); const blockToCheck = (checkIndex !== -1 && checkIndex < chunk.blocks.length) ? chunk.blocks[checkIndex] : getBlock(chunkX * CHUNK_SIZE + bx, surfaceY, chunkZ * CHUNK_SIZE + bz); if (blockToCheck === BLOCK_TYPES.ASPHALT || blockToCheck === BLOCK_TYPES.PARK_GRASS){ canBuild = false; break; } } if (!canBuild) break; } if (canBuild) { generateBuilding(worldX, surfaceY + 1, worldZ, buildingWidth, buildingDepth, buildingHeight, wallType); } } } else if (x % 7 === 0 && z % 7 === 3 && Math.random() < 0.08) { generateLampPost(worldX, surfaceY + 1, worldZ); } else if (Math.random() < 0.005) { const neighborX = getBlock(worldX+1, surfaceY, worldZ); const neighborNX = getBlock(worldX-1, surfaceY, worldZ); const neighborZ = getBlock(worldX, surfaceY, worldZ+1); const neighborNZ = getBlock(worldX, surfaceY, worldZ-1); if (neighborX === BLOCK_TYPES.ASPHALT || neighborNX === BLOCK_TYPES.ASPHALT) { generatePoliceBarrier(worldX, surfaceY + 1, worldZ, 3 + Math.floor(Math.random() * 3), 'z'); } else if (neighborZ === BLOCK_TYPES.ASPHALT || neighborNZ === BLOCK_TYPES.ASPHALT) { generatePoliceBarrier(worldX, surfaceY + 1, worldZ, 3 + Math.floor(Math.random() * 3), 'x'); } } } else if (blockOnSurface === BLOCK_TYPES.ASPHALT && surfaceY >= BASE_CITY_Y){ const neighborBlockZ = getBlock(worldX, surfaceY, worldZ + 1); const neighborBlockX = getBlock(worldX+1, surfaceY, worldZ); const isPolice = Math.random() < 0.15; if ((neighborBlockZ === BLOCK_TYPES.SIDEWALK || neighborBlockX === BLOCK_TYPES.SIDEWALK) && Math.random() < (isPolice ? 0.10 : 0.05)){ const carWidth = 2; const carDepth = 5; if(x + carWidth < CHUNK_SIZE && z + carDepth < CHUNK_SIZE){ let placeOk = true; for(let dx=0; dx<carWidth; dx++){ for(let dz=0; dz<carDepth; dz++){ if(getBlock(worldX+dx, surfaceY, worldZ+dz) !== BLOCK_TYPES.ASPHALT){ placeOk = false; break; } } if(!placeOk) break; } if(placeOk){ generateCar(worldX, surfaceY + 1, worldZ, isPolice); } } } } } } chunk.structuresGenerated = true; } chunksToGenerate.push({ chunkX: chunkX, chunkZ: chunkZ }); }
        function getSurfaceHeight(worldX, worldZ) { const { chunkX, chunkZ, localX, localZ } = worldToChunkCoords(worldX, CHUNK_HEIGHT - 1, worldZ); const chunk = world[getChunkKey(chunkX, chunkZ)]; if(!chunk || !chunk.blocks){ const groundNoise = (PerlinNoise.noise(worldX * NOISE_SCALE_GROUND, worldZ * NOISE_SCALE_GROUND, 10) + 1) / 2; return BASE_CITY_Y + Math.floor(groundNoise * WORLD_HEIGHT_VARIATION); } for(let y = CHUNK_HEIGHT - 1; y >= 0; y--){ const blockIndex = getBlockIndex(localX, y, localZ); if(blockIndex !== -1 && chunk.blocks[blockIndex] !== BLOCK_TYPES.AIR){ return y; } } return BASE_CITY_Y; }
        function generateChunkMesh(chunkX, chunkZ){ const key = getChunkKey(chunkX, chunkZ); const chunk = world[key]; if(!chunk || !chunk.blocks){ return; } if(chunk.mesh){ scene.remove(chunk.mesh); chunk.mesh.geometry.dispose(); chunk.mesh = null; } const positions = []; const normals = []; const colors = []; const indices = []; let vertexIndex = 0; const TOP_BRIGHTNESS = 1.0, SIDE_BRIGHTNESS = 0.8, BOTTOM_BRIGHTNESS = 0.6; for(let y = 0; y < CHUNK_HEIGHT; y++){ for(let z = 0; z < CHUNK_SIZE; z++){ for(let x = 0; x < CHUNK_SIZE; x++){ const blockIndex = getBlockIndex(x, y, z); if (blockIndex === -1) continue; const blockType = chunk.blocks[blockIndex]; if(blockType === BLOCK_TYPES.AIR) continue; const blockColorData = BLOCK_COLORS[blockType] || { top: 0x777777, side: 0x777777, bottom: 0x777777 }; const worldX = chunkX * CHUNK_SIZE + x; const worldY = y; const worldZ = chunkZ * CHUNK_SIZE + z; const isTransparent = (type) => type === BLOCK_TYPES.AIR || type === BLOCK_TYPES.WINDOW || type === BLOCK_TYPES.TREE_LEAVES; const neighbors = { nx: isTransparent(getBlockLocalOrNeighbor(chunkX, chunkZ, x - 1, y, z)), px: isTransparent(getBlockLocalOrNeighbor(chunkX, chunkZ, x + 1, y, z)), ny: isTransparent(getBlockLocalOrNeighbor(chunkX, chunkZ, x, y - 1, z)), py: isTransparent(getBlockLocalOrNeighbor(chunkX, chunkZ, x, y + 1, z)), nz: isTransparent(getBlockLocalOrNeighbor(chunkX, chunkZ, x, y, z - 1)), pz: isTransparent(getBlockLocalOrNeighbor(chunkX, chunkZ, x, y, z + 1)) }; if(neighbors.pz){ const faceColor = new THREE.Color(blockColorData.side); const C = SIDE_BRIGHTNESS; positions.push(worldX, worldY, worldZ + 1, worldX + 1, worldY, worldZ + 1, worldX + 1, worldY + 1, worldZ + 1, worldX, worldY + 1, worldZ + 1); normals.push(0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1); colors.push(faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C); indices.push(vertexIndex, vertexIndex + 1, vertexIndex + 2, vertexIndex, vertexIndex + 2, vertexIndex + 3); vertexIndex += 4; } if(neighbors.nz){ const faceColor = new THREE.Color(blockColorData.side); const C = SIDE_BRIGHTNESS; positions.push(worldX + 1, worldY, worldZ, worldX, worldY, worldZ, worldX, worldY + 1, worldZ, worldX + 1, worldY + 1, worldZ); normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1); colors.push(faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C); indices.push(vertexIndex, vertexIndex + 1, vertexIndex + 2, vertexIndex, vertexIndex + 2, vertexIndex + 3); vertexIndex += 4; } if(neighbors.px){ const faceColor = new THREE.Color(blockColorData.side); const C = SIDE_BRIGHTNESS; positions.push(worldX + 1, worldY, worldZ + 1, worldX + 1, worldY, worldZ, worldX + 1, worldY + 1, worldZ, worldX + 1, worldY + 1, worldZ + 1); normals.push(1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0); colors.push(faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C); indices.push(vertexIndex, vertexIndex + 1, vertexIndex + 2, vertexIndex, vertexIndex + 2, vertexIndex + 3); vertexIndex += 4; } if(neighbors.nx){ const faceColor = new THREE.Color(blockColorData.side); const C = SIDE_BRIGHTNESS; positions.push(worldX, worldY, worldZ, worldX, worldY, worldZ + 1, worldX, worldY + 1, worldZ + 1, worldX, worldY + 1, worldZ); normals.push(-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0); colors.push(faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C); indices.push(vertexIndex, vertexIndex + 1, vertexIndex + 2, vertexIndex, vertexIndex + 2, vertexIndex + 3); vertexIndex += 4; } if(neighbors.py){ const faceColor = new THREE.Color(blockColorData.top); const C = TOP_BRIGHTNESS; positions.push(worldX, worldY + 1, worldZ + 1, worldX + 1, worldY + 1, worldZ + 1, worldX + 1, worldY + 1, worldZ, worldX, worldY + 1, worldZ); normals.push(0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0); colors.push(faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C); indices.push(vertexIndex, vertexIndex + 1, vertexIndex + 2, vertexIndex, vertexIndex + 2, vertexIndex + 3); vertexIndex += 4; } if(neighbors.ny){ const faceColor = new THREE.Color(blockColorData.bottom); const C = BOTTOM_BRIGHTNESS; positions.push(worldX, worldY, worldZ, worldX + 1, worldY, worldZ, worldX + 1, worldY, worldZ + 1, worldX, worldY, worldZ + 1); normals.push(0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0); colors.push(faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C); indices.push(vertexIndex, vertexIndex + 1, vertexIndex + 2, vertexIndex, vertexIndex + 2, vertexIndex + 3); vertexIndex += 4; } } } } if(positions.length === 0){ return; } const geometry = new THREE.BufferGeometry(); geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3)); geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3)); geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3)); geometry.setIndex(indices); chunk.mesh = new THREE.Mesh(geometry, material); chunk.mesh.castShadow = true; chunk.mesh.receiveShadow = true; chunk.mesh.userData = { chunkX: chunkX, chunkZ: chunkZ }; scene.add(chunk.mesh); }
        function updateWorldChunks(){ let currentChunkX, currentChunkZ; let effectiveRenderDistance; let maxMeshesPerFrame; if(gameState === 'PLAYING'){ currentChunkX = Math.floor(camera.position.x / CHUNK_SIZE); currentChunkZ = Math.floor(camera.position.z / CHUNK_SIZE); effectiveRenderDistance = RENDER_DISTANCE; maxMeshesPerFrame = 2; } else if (menuCameraAnimation.active && gameState === 'MENU'){ currentChunkX = Math.floor(menuCameraAnimation.initialPosition.x / CHUNK_SIZE); currentChunkZ = Math.floor(menuCameraAnimation.initialPosition.z / CHUNK_SIZE); effectiveRenderDistance = 2; maxMeshesPerFrame = 4; } else { processChunkMeshUpdates(); return; } for(let x = currentChunkX - effectiveRenderDistance; x <= currentChunkX + effectiveRenderDistance; x++){ for(let z = currentChunkZ - effectiveRenderDistance; z <= currentChunkZ + effectiveRenderDistance; z++){ const key = getChunkKey(x, z); if(!world[key]){ generateChunkData(x, z); } else if (world[key].mesh === null && !chunksToGenerate.some(c => c.chunkX === x && c.chunkZ === z) && !scheduledMeshUpdates.has(key)) { if(Math.abs(x - currentChunkX) <= effectiveRenderDistance && Math.abs(z - currentChunkZ) <= effectiveRenderDistance) { chunksToGenerate.push({ chunkX: x, chunkZ: z }); } } } } let meshesGeneratedThisFrame = 0; while (meshesGeneratedThisFrame < maxMeshesPerFrame && chunksToGenerate.length > 0) { const { chunkX, chunkZ } = chunksToGenerate.shift(); if(Math.abs(chunkX - currentChunkX) <= effectiveRenderDistance && Math.abs(chunkZ - currentChunkZ) <= effectiveRenderDistance) { if(world[getChunkKey(chunkX, chunkZ)]) { generateChunkMesh(chunkX, chunkZ); meshesGeneratedThisFrame++; } } } processChunkMeshUpdates(); if(gameState === 'PLAYING'){ const unloadDistance = RENDER_DISTANCE + 1; const chunksToRemoveKeys = []; for (const key in world) { const chunk = world[key]; if (chunk.mesh || chunk.blocks) { const [cx, cz] = key.split(',').map(Number); if(Math.abs(cx - currentChunkX) > unloadDistance || Math.abs(cz - currentChunkZ) > unloadDistance){ chunksToRemoveKeys.push(key); } } } chunksToRemoveKeys.forEach(key => { const chunkToRemove = world[key]; if (chunkToRemove) { if (chunkToRemove.mesh) { scene.remove(chunkToRemove.mesh); chunkToRemove.mesh.geometry.dispose(); chunkToRemove.mesh = null; } delete world[key]; } }); const entityUnloadDistanceChunks = RENDER_DISTANCE + 2; const playerChunkX = Math.floor(camera.position.x / CHUNK_SIZE); const playerChunkZ = Math.floor(camera.position.z / CHUNK_SIZE); for(let i = policeEntities.length - 1; i >= 0; i--){ const entity = policeEntities[i]; if (!entity || !entity.position) continue; const entityChunkX = Math.floor(entity.position.x / CHUNK_SIZE); const entityChunkZ = Math.floor(entity.position.z / CHUNK_SIZE); if(Math.abs(entityChunkX - playerChunkX) > entityUnloadDistanceChunks || Math.abs(entityChunkZ - playerChunkZ) > entityUnloadDistanceChunks){ if(entity.mesh) scene.remove(entity.mesh); policeEntities.splice(i, 1); } } } }

        function updatePlayer(deltaTime) {
             if (gameState !== 'PLAYING' || playerHealth <= 0) return;
             let currentMoveSpeed = MOVE_SPEED;
             let isMoving = false;
             if (isMobile) { isMoving = joystickMagnitude > 0.1; } else { isMoving = keys['KeyW'] || keys['KeyS'] || keys['KeyA'] || keys['KeyD']; }
             if(isSprinting && playerOnGround && isMoving && playerStamina > 0){ currentMoveSpeed = MOVE_SPEED * sprintMultiplier; playerStamina -= STAMINA_DRAIN_RATE * deltaTime; if(playerStamina <= 0){ playerStamina = 0; isSprinting = false; targetFov = originalFov; showNotification("Dayanıklılık tükendi!"); } } else if (playerStamina < MAX_STAMINA && !isSprinting) { playerStamina += STAMINA_REGEN_RATE * deltaTime; playerStamina = Math.min(playerStamina, MAX_STAMINA); }
             if(isSprinting && isMoving && playerStamina <= 0 && playerOnGround){ playerHealth -= STAMINA_HEALTH_DRAIN_RATE * deltaTime; lastDamageTime = clock.elapsedTime; if(playerHealth <= 0){ handlePlayerDeath(); return; } }

             if(playerHealth < MAX_HEALTH && clock.elapsedTime > lastDamageTime + HEALTH_REGEN_DELAY && !isInGasCloud(camera.position)){
                 playerHealth += HEALTH_REGEN_RATE * deltaTime;
                 playerHealth = Math.min(playerHealth, MAX_HEALTH);
             }

             const forwardDirection = new THREE.Vector3(); camera.getWorldDirection(forwardDirection); forwardDirection.y = 0; forwardDirection.normalize();
             const rightDirection = new THREE.Vector3(); rightDirection.crossVectors(camera.up, forwardDirection).normalize();
             let moveForward = 0; let moveRight = 0;
             if(joystickActive){ moveForward = -joystickDeltaY * joystickMagnitude; moveRight = joystickDeltaX * joystickMagnitude; } else if (!isMobile) { if(keys['KeyW']) moveForward += 1; if(keys['KeyS']) moveForward -= 1; if(keys['KeyA']) moveRight -= 1; if(keys['KeyD']) moveRight += 1; }
             const moveDirection = new THREE.Vector3(); moveDirection.addScaledVector(forwardDirection, moveForward); moveDirection.addScaledVector(rightDirection, moveRight); moveDirection.normalize();
             playerVelocity.y += GRAVITY * deltaTime;
             if(!isMobile && keys['Space'] && playerOnGround){ playerVelocity.y = JUMP_VELOCITY; playerOnGround = false; }
             const deltaPosition = moveDirection.multiplyScalar(currentMoveSpeed * deltaTime);
             const physicsDelta = playerVelocity.clone().multiplyScalar(deltaTime);
             const playerBoundingBoxSize = new THREE.Vector3(PLAYER_RADIUS * 2, PLAYER_HEIGHT, PLAYER_RADIUS * 2);
             const playerHeightOffset = PLAYER_HEIGHT / 2;
             playerOnGround = false;
             let targetPosX = camera.position.clone().add(new THREE.Vector3(deltaPosition.x + physicsDelta.x, 0, 0));
             if (!checkCollision(targetPosX, playerBoundingBoxSize, playerHeightOffset)) { camera.position.x = targetPosX.x; } else { playerVelocity.x = 0; }
             let targetPosZ = camera.position.clone().add(new THREE.Vector3(0, 0, deltaPosition.z + physicsDelta.z));
             if (!checkCollision(targetPosZ, playerBoundingBoxSize, playerHeightOffset)) { camera.position.z = targetPosZ.z; } else { playerVelocity.z = 0; }
             let targetPosY = camera.position.clone().add(new THREE.Vector3(0, physicsDelta.y, 0));
             if (!checkCollision(targetPosY, playerBoundingBoxSize, playerHeightOffset)) { camera.position.y = targetPosY.y; } else { if (physicsDelta.y < 0) { playerOnGround = true; const collisionFloorY = Math.floor(camera.position.y - playerHeightOffset + physicsDelta.y); camera.position.y = collisionFloorY + 1 + playerHeightOffset + COLLISION_EPSILON; playerVelocity.y = 0; } else if (physicsDelta.y > 0) { const collisionCeilY = Math.ceil(camera.position.y + (PLAYER_HEIGHT - playerHeightOffset) + physicsDelta.y); camera.position.y = collisionCeilY - 1 - (PLAYER_HEIGHT - playerHeightOffset) - COLLISION_EPSILON; playerVelocity.y = 0; } }
             if(camera.position.y < playerHeightOffset){ camera.position.y = playerHeightOffset + COLLISION_EPSILON; playerVelocity.y = 0; playerOnGround = true; }
             const groundDamping = 0.85; const airDamping = 0.98; if (playerOnGround) { playerVelocity.x *= groundDamping; playerVelocity.z *= groundDamping; } else { playerVelocity.x *= airDamping; playerVelocity.z *= airDamping; }
             const fovLerpFactor = 0.1; camera.fov = THREE.MathUtils.lerp(camera.fov, targetFov, fovLerpFactor); camera.updateProjectionMatrix();
             updateWindLines(deltaTime); updateHealthStaminaUI(); updateGasClouds(deltaTime);
             if(controls && controls.getObject()){ controls.getObject().position.copy(camera.position); }
        }

        function checkCollision(centerPosition, boundingBoxSize, heightOffset){ const halfSize = boundingBoxSize.clone().multiplyScalar(0.5); const playerBox = new THREE.Box3( new THREE.Vector3(centerPosition.x - halfSize.x, centerPosition.y - heightOffset, centerPosition.z - halfSize.z), new THREE.Vector3(centerPosition.x + halfSize.x, centerPosition.y + (boundingBoxSize.y - heightOffset), centerPosition.z + halfSize.z) ); const minX = Math.floor(playerBox.min.x - COLLISION_EPSILON); const maxX = Math.ceil(playerBox.max.x + COLLISION_EPSILON); const minY = Math.floor(playerBox.min.y - COLLISION_EPSILON); const maxY = Math.ceil(playerBox.max.y + COLLISION_EPSILON); const minZ = Math.floor(playerBox.min.z - COLLISION_EPSILON); const maxZ = Math.ceil(playerBox.max.z + COLLISION_EPSILON); for(let y = minY; y < maxY; y++){ for(let z = minZ; z < maxZ; z++){ for(let x = minX; x < maxX; x++){ const blockType = getBlock(x, y, z); const isSolid = blockType !== BLOCK_TYPES.AIR && blockType !== BLOCK_TYPES.WINDOW && blockType !== BLOCK_TYPES.TREE_LEAVES; if(isSolid){ const blockBox = new THREE.Box3( new THREE.Vector3(x, y, z), new THREE.Vector3(x + 1, y + 1, z + 1) ); if(playerBox.intersectsBox(blockBox)){ return true; } } } } } return false; }

        function updateHealthStaminaUI(){ if(!canCubuguIc || !dayaniklilikCubuguIc) return; const healthPercent = Math.max(0, playerHealth) / MAX_HEALTH * 100; const staminaPercent = Math.max(0, playerStamina) / MAX_STAMINA * 100; canCubuguIc.style.width = `${healthPercent}%`; dayaniklilikCubuguIc.style.width = `${staminaPercent}%`; }
        function setupSprintUI(){ if(kosmaKaydirici && kosmaHiziDegeriUI){ kosmaKaydirici.addEventListener('input', (e)=>{ sprintMultiplier = parseFloat(e.target.value); kosmaHiziDegeriUI.textContent = `${sprintMultiplier.toFixed(1)}x`; }); sprintMultiplier = parseFloat(kosmaKaydirici.value); kosmaHiziDegeriUI.textContent = `${sprintMultiplier.toFixed(1)}x`; } }
        function showNotification(message){ if(!bildirimUI) return; bildirimUI.textContent = message; bildirimUI.style.display = 'block'; bildirimUI.style.top = '20px'; bildirimUI.style.opacity = '1'; setTimeout(()=>{ if(!bildirimUI) return; bildirimUI.style.opacity = '0'; bildirimUI.style.top = '-50px'; setTimeout(()=>{ if(!bildirimUI) return; bildirimUI.style.display = 'none'; }, 300); }, 1500); }
        function createWindLines(){ const lineCount = 50; const geometry = new THREE.BufferGeometry(); const positions = new Float32Array(lineCount * 6); const colors = new Float32Array(lineCount * 6); for(let i = 0; i < lineCount; i++){ const index = i * 6; positions[index+0]=0; positions[index+1]=0; positions[index+2]=-1; positions[index+3]=0; positions[index+4]=0; positions[index+5]=-1; colors[index+0]=1; colors[index+1]=1; colors[index+2]=1; colors[index+3]=1; colors[index+4]=1; colors[index+5]=1; } geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3)); const material = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.4, depthTest: false, depthWrite: false }); windLinesMesh = new THREE.LineSegments(geometry, material); windLinesMesh.visible = false; camera.add(windLinesMesh); }
        function updateWindLines(deltaTime){ if(!windLinesMesh) return; if(!isSprinting || playerHealth <= 0 || gameState !== 'PLAYING'){ windLinesMesh.visible = false; return; } if(!windLinesMesh.visible) windLinesMesh.visible = true; const positions = windLinesMesh.geometry.attributes.position.array; const lineCount = positions.length / 6; const speedFactor = (sprintMultiplier / SPRINT_MULTIPLIER_DEFAULT); const baseLineLength = 0.3 * speedFactor; const screenEdgeFactor = 1.8; for(let i = 0; i < lineCount; i++){ const startIndex = i * 6; const endIndex = startIndex + 3; if(positions[endIndex + 2] >= 0 || positions[startIndex + 2] === -1) { const angle = Math.random() * Math.PI * 2; const radius = (Math.random() * 0.5 + 0.6) * screenEdgeFactor; positions[startIndex + 0] = Math.cos(angle) * radius; positions[startIndex + 1] = Math.sin(angle) * radius; positions[startIndex + 2] = -Math.random() * 3 - 1; positions[endIndex + 0] = positions[startIndex + 0]; positions[endIndex + 1] = positions[startIndex + 1]; positions[endIndex + 2] = positions[startIndex + 2]; } const moveSpeed = (15 + Math.random() * 10) * speedFactor * deltaTime; positions[startIndex + 2] += moveSpeed; positions[endIndex + 2] = positions[startIndex + 2] + baseLineLength * (1 + Math.random() * 0.3); const shrinkFactor = 0.97; positions[startIndex + 0] *= shrinkFactor; positions[startIndex + 1] *= shrinkFactor; positions[endIndex + 0] = positions[startIndex + 0]; positions[endIndex + 1] = positions[startIndex + 1]; } windLinesMesh.geometry.attributes.position.needsUpdate = true; }
        function showDamageEffect(position, intensity = 1.0){ if(!hasarKaplamasi) return; hasarKaplamasi.style.display = 'block'; hasarKaplamasi.style.backgroundColor = `rgba(200, 0, 0, ${0.5 * intensity})`; hasarKaplamasi.style.opacity = '1'; setTimeout(()=>{ if(!hasarKaplamasi) return; hasarKaplamasi.style.opacity = '0'; setTimeout(()=>{ if(!hasarKaplamasi) return; hasarKaplamasi.style.display = 'none'; }, 50); }, 50); }
        let pepperSprayScreenEffectActive = false;
        function startPepperSprayScreenEffect(){ if(!pepperSprayScreenEffectActive){ pepperSprayScreenEffectActive = true; biberGaziKaplamasi.style.display = 'block'; requestAnimationFrame(() => { if(biberGaziKaplamasi) biberGaziKaplamasi.style.opacity = '0.7'; }); } }
        function stopPepperSprayScreenEffect(){ if(pepperSprayScreenEffectActive){ pepperSprayScreenEffectActive = false; biberGaziKaplamasi.style.opacity = '0'; setTimeout(()=>{ if (!pepperSprayScreenEffectActive && biberGaziKaplamasi) { biberGaziKaplamasi.style.display = 'none'; } }, 200); } }

        function createParticleSystem(count, originPosition, color, type, velocityMinMax = {min: 1, max: 4}, lifetimeMinMax = {min: 0.4, max: 1.0}, gravityMultiplier = 1.0, size = 0.1, materialOverride = null){ const geometry = new THREE.BufferGeometry(); const positions = new Float32Array(count * 3); const velocities = new Float32Array(count * 3); const lifetimes = new Float32Array(count); const initialLifetimes = new Float32Array(count); const velocityRange = velocityMinMax.max - velocityMinMax.min; const lifetimeRange = lifetimeMinMax.max - lifetimeMinMax.min; for(let i = 0; i < count; i++){ const i3 = i * 3; positions[i3 + 0] = originPosition.x + (Math.random() - 0.5) * 0.1; positions[i3 + 1] = originPosition.y + (Math.random() - 0.5) * 0.1; positions[i3 + 2] = originPosition.z + (Math.random() - 0.5) * 0.1; let vx, vy, vz; const lifetime = lifetimeMinMax.min + Math.random() * lifetimeRange; const speed = velocityMinMax.min + Math.random() * velocityRange; if(type === 'blood'){ const phi = Math.random() * Math.PI * 2; const costheta = Math.random() * 2 - 1; const sintheta = Math.sqrt(1 - costheta * costheta); vx = speed * sintheta * Math.cos(phi); vy = speed * costheta; vz = speed * sintheta * Math.sin(phi); } else if (type === 'gas_cloud'){ const angle = Math.random() * Math.PI * 2; const radiusSpeed = Math.random() * speed * 0.5; vx = Math.cos(angle) * radiusSpeed; vy = Math.random() * speed * 0.8 + 0.2; vz = Math.sin(angle) * radiusSpeed; } else if (type === 'sound_wave') { const phi = Math.random() * Math.PI * 2; const costheta = Math.random() * 2 - 1; const sintheta = Math.sqrt(1 - costheta*costheta); vx = speed * sintheta * Math.cos(phi); vy = speed * costheta; vz = speed * sintheta * Math.sin(phi); } else { const angle = Math.random() * Math.PI * 2; vx = Math.cos(angle) * speed * (Math.random() * 0.5 + 0.5); vy = Math.random() * speed * 1.5 + speed * 0.5; vz = Math.sin(angle) * speed * (Math.random() * 0.5 + 0.5); } velocities[i3 + 0] = vx; velocities[i3 + 1] = vy; velocities[i3 + 2] = vz; lifetimes[i] = lifetime; initialLifetimes[i] = lifetime; } geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3)); geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1)); geometry.setAttribute('initialLifetime', new THREE.BufferAttribute(initialLifetimes, 1)); let materialInstance; if (materialOverride) { materialInstance = materialOverride; } else if(type === 'gas_cloud'){ materialInstance = gasCloudMaterial.clone(); } else { materialInstance = new THREE.PointsMaterial({ color: color, size: size, transparent: true, opacity: 0.9, sizeAttenuation: true, depthWrite: false, blending: THREE.NormalBlending }); } const points = new THREE.Points(geometry, materialInstance); points.userData = { type: type, startTime: clock.elapsedTime, gravityMultiplier: gravityMultiplier }; scene.add(points); activeParticles.push(points); return points; }
        function updateParticles(deltaTime){ const gravityForce = GRAVITY; for(let i = activeParticles.length - 1; i >= 0; i--){ const points = activeParticles[i]; if(!points || !points.geometry || !points.material) { activeParticles.splice(i, 1); const cloudIndex = gasClouds.findIndex(c => c.mesh === points); if(cloudIndex > -1) gasClouds.splice(cloudIndex, 1); continue; } const geometry = points.geometry; const positions = geometry.attributes.position.array; const velocities = geometry.attributes.velocity.array; const lifetimes = geometry.attributes.lifetime.array; const initialLifetimes = geometry.attributes.initialLifetime.array; const gravityMultiplier = points.userData.gravityMultiplier !== undefined ? points.userData.gravityMultiplier : 1.0; const particleType = points.userData.type; let activeCount = 0; let totalInitialLifetime = 0; let totalRemainingLifetime = 0; const numParticles = lifetimes.length; for(let j = 0; j < numParticles; j++){ lifetimes[j] -= deltaTime; if(lifetimes[j] > 0){ const i3 = j * 3; if (particleType !== 'sound_wave') { velocities[i3 + 1] += gravityForce * gravityMultiplier * deltaTime; } positions[i3 + 0] += velocities[i3 + 0] * deltaTime; positions[i3 + 1] += velocities[i3 + 1] * deltaTime; positions[i3 + 2] += velocities[i3 + 2] * deltaTime; if(particleType === 'blood'){ const groundY = getSurfaceHeight(positions[i3 + 0], positions[i3 + 2]); if(positions[i3 + 1] < groundY + 0.05){ positions[i3 + 1] = groundY + 0.05; velocities[i3 + 1] *= -0.2; velocities[i3 + 0] *= 0.5; velocities[i3 + 2] *= 0.5; lifetimes[j] *= 0.5; } } else if (particleType === 'gas_cloud') { velocities[i3 + 0] *= 0.95; velocities[i3 + 1] *= 0.97; velocities[i3 + 2] *= 0.95; } else if (particleType === 'sound_wave') { velocities[i3 + 0] *= 0.96; velocities[i3 + 1] *= 0.96; velocities[i3 + 2] *= 0.96; } activeCount++; totalInitialLifetime += initialLifetimes[j]; totalRemainingLifetime += lifetimes[j]; } else { const i3 = j * 3; positions[i3 + 0] = 0; positions[i3 + 1] = -10000; positions[i3 + 2] = 0; } } if(points.material.opacity !== undefined && totalInitialLifetime > 0){ const averageLifetimeRatio = totalRemainingLifetime / totalInitialLifetime; points.material.opacity = Math.max(0, Math.min(0.8, averageLifetimeRatio * 1.5)); } if(activeCount === 0){ scene.remove(points); geometry.dispose(); if(points.material !== gasCloudMaterial && points.material !== soundWaveMaterial) { points.material.dispose(); } activeParticles.splice(i, 1); const cloudIndex = gasClouds.findIndex(c => c.mesh === points); if(cloudIndex > -1) gasClouds.splice(cloudIndex, 1); } else { geometry.attributes.position.needsUpdate = true; geometry.attributes.velocity.needsUpdate = true; geometry.attributes.lifetime.needsUpdate = true; } } }
        function createBloodEffect(position){ createParticleSystem(BLOOD_PARTICLE_COUNT, position, 0x990000, 'blood', { min: 1, max: 4 }, { min: 0.4, max: 1.0 }, 1.0, 0.06); }
        function createGasCloud(position){ playSound(gazTislamaSesi); const cloudMesh = createParticleSystem(GAS_PARTICLE_COUNT, position, 0xb0b0b0, 'gas_cloud', { min: 0.2, max: 0.8 }, { min: PEPPER_SPRAY_DURATION * 0.8, max: PEPPER_SPRAY_DURATION * 1.2 }, -0.05, 0.2, gasCloudMaterial); gasClouds.push({ position: position.clone(), startTime: clock.elapsedTime, mesh: cloudMesh }); }
        function updateGasClouds(deltaTime){ const playerPosition = camera.position; if(playerHealth <= 0 || gameState !== 'PLAYING') { stopPepperSprayScreenEffect(); return; } let inAnyCloud = false; for(const cloud of gasClouds){ if(playerPosition.distanceToSquared(cloud.position) < PEPPER_GAS_CLOUD_SIZE * PEPPER_GAS_CLOUD_SIZE){ inAnyCloud = true; break; } } if(inAnyCloud){ startPepperSprayScreenEffect(); dealDamageToPlayer(POLICE_DAMAGE.PEPPER_SPRAY_DOT * deltaTime, 'pepper_spray_dot'); } else { stopPepperSprayScreenEffect(); } }
        function isInGasCloud(position){ for(const cloud of gasClouds){ if(position.distanceToSquared(cloud.position) < PEPPER_GAS_CLOUD_SIZE * PEPPER_GAS_CLOUD_SIZE){ return true; } } return false; }

        function createPoliceMesh(){ const group = new THREE.Group(); const bodyHeight = 0.8, bodyWidth = 0.55, bodyDepth = 0.35; const headSize = 0.4; const vestThickness = 0.04; const bodyGeo = new THREE.BoxGeometry(bodyWidth, bodyHeight, bodyDepth); const bodyMesh = new THREE.Mesh(bodyGeo, policeMaterials.body); bodyMesh.position.y = bodyHeight / 2; group.add(bodyMesh); const vestGeo = new THREE.BoxGeometry(bodyWidth + vestThickness, bodyHeight * 0.8, bodyDepth + vestThickness); const vestMesh = new THREE.Mesh(vestGeo, policeMaterials.vest); vestMesh.position.y = bodyHeight * 0.5; group.add(vestMesh); const headGeo = new THREE.BoxGeometry(headSize, headSize, headSize); const headMesh = new THREE.Mesh(headGeo, policeMaterials.skin); headMesh.position.y = bodyHeight + headSize / 2; group.add(headMesh); const helmetGeo = new THREE.BoxGeometry(headSize + 0.08, headSize * 0.55, headSize + 0.08); const helmetMesh = new THREE.Mesh(helmetGeo, policeMaterials.helmet); helmetMesh.position.y = bodyHeight + headSize * 0.75; group.add(helmetMesh); const armGeo = new THREE.BoxGeometry(0.12, bodyHeight * 0.9, 0.12); const leftArm = new THREE.Mesh(armGeo, policeMaterials.body); leftArm.position.set(-(bodyWidth / 2 + 0.08), bodyHeight / 2, 0); group.add(leftArm); const rightArm = new THREE.Mesh(armGeo, policeMaterials.body); rightArm.position.set(bodyWidth / 2 + 0.08, bodyHeight / 2, 0); group.add(rightArm); const totalHeight = bodyHeight + headSize + 0.1; const totalWidth = bodyWidth + 0.16 * 2; const totalDepth = bodyDepth + 0.16; group.userData.entityType = 'police'; group.userData.boundingBoxSize = new THREE.Vector3(totalWidth, totalHeight, totalDepth); group.traverse((child) => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = false; child.name = `police_part_${child.uuid.substring(0, 4)}`; } }); return group; }
        function spawnPolice(position){ if(policeEntities.length >= MAX_POLICE) return; const mesh = createPoliceMesh(); mesh.position.copy(position); const boundingBox = mesh.userData.boundingBoxSize || new THREE.Vector3(0.8, 1.6, 0.6); const heightOffset = boundingBox.y / 2; const groundY = getSurfaceHeight(position.x, position.z); mesh.position.y = groundY + heightOffset + COLLISION_EPSILON; scene.add(mesh); const entity = { id: nextEntityId++, type: 'police', mesh: mesh, position: mesh.position, velocity: new THREE.Vector3(), onGround: true, boundingBoxSize: boundingBox, heightOffset: heightOffset, targetAngle: Math.random() * Math.PI * 2, wanderTimer: Math.random() * 4 + 2, health: MAX_HEALTH, maxHealth: MAX_HEALTH, attackCooldownGas: 0, attackCooldownBullet: 0, state: 'wander', targetPlayer: null }; entity.mesh.userData.entityId = entity.id; policeEntities.push(entity); }
        function updateEntities(deltaTime){ const playerPosition = camera.position; const isPlayerAliveAndPlaying = (gameState === 'PLAYING' && playerHealth > 0); for(let i = policeEntities.length - 1; i >= 0; i--){ const entity = policeEntities[i]; if(!entity || !entity.mesh || !entity.position) { if (entity && !entity.mesh) { policeEntities.splice(i, 1); } continue; } if(entity.attackCooldownGas > 0) entity.attackCooldownGas -= deltaTime; if(entity.attackCooldownBullet > 0) entity.attackCooldownBullet -= deltaTime; let targetVelocityX = 0; let targetVelocityZ = 0; const currentMoveSpeed = POLICE_MOVE_SPEED; entity.targetPlayer = null; if(isPlayerAliveAndPlaying){ const distanceToPlayer = entity.position.distanceTo(playerPosition); if(distanceToPlayer < POLICE_DETECT_RANGE){ const directionToPlayer = playerPosition.clone().sub(entity.position).normalize(); const rayOrigin = entity.position.clone().add(new THREE.Vector3(0, entity.heightOffset * 0.8, 0)); raycaster.set(rayOrigin, directionToPlayer); raycaster.far = distanceToPlayer + 0.5; const worldMeshes = Object.values(world).map(c => c.mesh).filter(m => m !== null); const intersects = raycaster.intersectObjects(worldMeshes, false); if(intersects.length === 0 || intersects[0].distance > distanceToPlayer - 0.5){ entity.targetPlayer = playerPosition; entity.targetAngle = Math.atan2(directionToPlayer.x, directionToPlayer.z); } } } if(entity.targetPlayer){ const distanceToTarget = entity.position.distanceTo(entity.targetPlayer); const directionToTarget = entity.targetPlayer.clone().sub(entity.position).normalize(); if(distanceToTarget < POLICE_ATTACK_RANGE_GAS && entity.attackCooldownGas <= 0){ entity.state = 'attacking_gas'; entity.velocity.x = 0; entity.velocity.z = 0; const launchPosition = entity.position.clone().add(new THREE.Vector3(0, entity.heightOffset * 0.7, 0)); const launchDirection = directionToTarget.clone(); launchDirection.y += 0.1 + Math.random() * 0.1; launchDirection.normalize(); launchProjectile(PROJECTILE_TYPES.GAS_CAPSULE, launchPosition, launchDirection.multiplyScalar(GAS_CAPSULE_SPEED), 'police'); playSound(gazFirlatmaSesi); entity.attackCooldownGas = POLICE_ATTACK_COOLDOWN_GAS + Math.random(); } else if (distanceToTarget < POLICE_ATTACK_RANGE_BULLET && entity.attackCooldownBullet <= 0) { entity.state = 'attacking_bullet'; entity.velocity.x = 0; entity.velocity.z = 0; const launchPosition = entity.position.clone().add(new THREE.Vector3(0, entity.heightOffset * 0.8, 0)); const accuracy = 0.05; const launchDirection = directionToTarget.clone().add( new THREE.Vector3( (Math.random() - 0.5) * accuracy, (Math.random() - 0.5) * accuracy, (Math.random() - 0.5) * accuracy )).normalize(); launchProjectile(PROJECTILE_TYPES.POLICE_BULLET, launchPosition, launchDirection.multiplyScalar(BULLET_SPEED), 'police', POLICE_DAMAGE.PLASTIC_BULLET); playSound(silahAtesSesi, 0.5); entity.attackCooldownBullet = POLICE_ATTACK_COOLDOWN_BULLET + Math.random() * 0.5; } else if (distanceToTarget >= POLICE_ATTACK_RANGE_GAS * 0.5) { entity.state = 'chasing'; targetVelocityX = directionToTarget.x * currentMoveSpeed; targetVelocityZ = directionToTarget.z * currentMoveSpeed; } else { entity.state = 'chasing_close'; targetVelocityX = directionToTarget.x * currentMoveSpeed * -0.2; targetVelocityZ = directionToTarget.z * currentMoveSpeed * -0.2; } } else { entity.state = 'wander'; } if(entity.state === 'wander'){ entity.wanderTimer -= deltaTime; if(entity.onGround){ if(entity.wanderTimer <= 0){ if(Math.random() < 0.8){ entity.targetAngle = Math.random() * Math.PI * 2; } else { entity.targetAngle = null; } entity.wanderTimer = Math.random() * 3 + 1.5; } if(entity.targetAngle !== null && entity.wanderTimer > 0.5){ targetVelocityX = Math.sin(entity.targetAngle) * currentMoveSpeed * 0.5; targetVelocityZ = Math.cos(entity.targetAngle) * currentMoveSpeed * 0.5; } else { targetVelocityX = 0; targetVelocityZ = 0; } } else { targetVelocityX = entity.velocity.x * 0.98; targetVelocityZ = entity.velocity.z * 0.98; } } entity.velocity.y += GRAVITY * deltaTime; const lerpFactor = 0.15; entity.velocity.x = THREE.MathUtils.lerp(entity.velocity.x, targetVelocityX, lerpFactor); entity.velocity.z = THREE.MathUtils.lerp(entity.velocity.z, targetVelocityZ, lerpFactor); const deltaPhysics = entity.velocity.clone().multiplyScalar(deltaTime); entity.onGround = false; const currentPos = entity.position; const bboxSize = entity.boundingBoxSize; const heightOff = entity.heightOffset; let targetPosX = currentPos.clone().add(new THREE.Vector3(deltaPhysics.x, 0, 0)); if (!checkCollision(targetPosX, bboxSize, heightOff)) { entity.position.x = targetPosX.x; } else { entity.velocity.x *= -0.1; if(entity.state === 'wander' || entity.state === 'chasing') entity.wanderTimer = 0.1; } let targetPosZ = currentPos.clone().add(new THREE.Vector3(0, 0, deltaPhysics.z)); if (!checkCollision(targetPosZ, bboxSize, heightOff)) { entity.position.z = targetPosZ.z; } else { entity.velocity.z *= -0.1; if(entity.state === 'wander' || entity.state === 'chasing') entity.wanderTimer = 0.1; } let targetPosY = currentPos.clone().add(new THREE.Vector3(0, deltaPhysics.y, 0)); if (!checkCollision(targetPosY, bboxSize, heightOff)) { entity.position.y = targetPosY.y; } else { if (deltaPhysics.y < 0) { entity.onGround = true; const floorY = Math.floor(currentPos.y - heightOff + deltaPhysics.y); entity.position.y = floorY + 1 + heightOff + COLLISION_EPSILON; entity.velocity.y = 0; } else { const ceilY = Math.ceil(currentPos.y + (bboxSize.y - heightOff) + deltaPhysics.y); entity.position.y = ceilY - 1 - (bboxSize.y - heightOff) - COLLISION_EPSILON; entity.velocity.y = 0; } } if(entity.position.y < heightOff){ entity.position.y = heightOff + COLLISION_EPSILON; entity.velocity.y = 0; entity.onGround = true; } if(Math.abs(entity.velocity.x) > 0.01 || Math.abs(entity.velocity.z) > 0.01 || entity.state.startsWith('attacking')){ if (entity.targetAngle !== null) { const targetYRotation = entity.targetAngle; let deltaRotation = targetYRotation - entity.mesh.rotation.y; while (deltaRotation < -Math.PI) deltaRotation += Math.PI * 2; while (deltaRotation > Math.PI) deltaRotation -= Math.PI * 2; entity.mesh.rotation.y += deltaRotation * 0.15; } } if(entity.health <= 0){ if(entity.mesh) scene.remove(entity.mesh); policeEntities.splice(i, 1); showNotification("Ajan etkisiz hale getirildi."); } } }

        function launchProjectile(type, position, velocity, owner = 'police', damageOverride = null){ let geometry, materialInstance, scale = 1.0, lifetime = PROJECTILE_MAX_LIFETIME; let hitCallback = null; let isBulletType = false; let damage = 0; switch(type){ case PROJECTILE_TYPES.GAS_CAPSULE: geometry = new THREE.CapsuleGeometry(0.06, 0.12, 4, 8); materialInstance = projectileMaterials[type].clone(); damage = POLICE_DAMAGE.PEPPER_SPRAY_IMPACT; hitCallback = (hitPos) => createGasCloud(hitPos); break; case PROJECTILE_TYPES.POLICE_BULLET: geometry = new THREE.SphereGeometry(0.05, 6, 4); materialInstance = projectileMaterials[type]; lifetime = 0.8; isBulletType = true; hitCallback = (hitPos) => { }; damage = damageOverride !== null ? damageOverride : POLICE_DAMAGE.PLASTIC_BULLET; break; default: return; } const mesh = new THREE.Mesh(geometry, materialInstance); mesh.scale.set(scale, scale, scale); mesh.position.copy(position); mesh.castShadow = false; mesh.receiveShadow = false; mesh.userData.isProjectile = true; const projectile = { id: nextEntityId++, type: type, mesh: mesh, position: mesh.position, velocity: velocity.clone(), owner: owner, damage: damage, lifetime: lifetime, spawnTime: clock.elapsedTime, hitCallback: hitCallback, isBullet: isBulletType }; projectiles.push(projectile); scene.add(mesh); }
        function updateProjectiles(deltaTime){ const playerPosition = camera.position; for(let i = projectiles.length - 1; i >= 0; i--){ const proj = projectiles[i]; if(clock.elapsedTime - proj.spawnTime > proj.lifetime){ if(proj.mesh) scene.remove(proj.mesh); projectiles.splice(i, 1); continue; } if(!proj.isBullet){ proj.velocity.y += GRAVITY * 0.7 * deltaTime; } const deltaMove = proj.velocity.clone().multiplyScalar(deltaTime); const nextPosition = proj.position.clone().add(deltaMove); let hit = false; let hitPosition = nextPosition.clone(); const projectileRadius = proj.isBullet ? 0.1 : 0.2; const projBBox = new THREE.Box3().setFromCenterAndSize(nextPosition, new THREE.Vector3(projectileRadius * 2, projectileRadius * 2, projectileRadius * 2)); const minX = Math.floor(Math.min(proj.position.x, nextPosition.x) - projectileRadius); const maxX = Math.ceil(Math.max(proj.position.x, nextPosition.x) + projectileRadius); const minY = Math.floor(Math.min(proj.position.y, nextPosition.y) - projectileRadius); const maxY = Math.ceil(Math.max(proj.position.y, nextPosition.y) + projectileRadius); const minZ = Math.floor(Math.min(proj.position.z, nextPosition.z) - projectileRadius); const maxZ = Math.ceil(Math.max(proj.position.z, nextPosition.z) + projectileRadius); for(let y = minY; y < maxY && !hit; y++){ for(let z = minZ; z < maxZ && !hit; z++){ for(let x = minX; x < maxX && !hit; x++){ const blockType = getBlock(x, y, z); const isSolid = blockType !== BLOCK_TYPES.AIR && blockType !== BLOCK_TYPES.WINDOW && blockType !== BLOCK_TYPES.TREE_LEAVES; if(isSolid){ const blockBox = new THREE.Box3(new THREE.Vector3(x, y, z), new THREE.Vector3(x + 1, y + 1, z + 1)); if(projBBox.intersectsBox(blockBox)){ hit = true; hitPosition = proj.position.clone(); if(proj.isBullet) playSound(mermiCarpmaSesi); break; } } } } } if(!hit && proj.owner === 'police' && playerHealth > 0 && gameState === 'PLAYING'){ const playerHitBoxSize = new THREE.Vector3(PLAYER_RADIUS * 1.8, PLAYER_HEIGHT * 0.9, PLAYER_RADIUS * 1.8); const playerBox = new THREE.Box3().setFromCenterAndSize( playerPosition.clone().add(new THREE.Vector3(0, -PLAYER_HEIGHT * 0.05, 0)), playerHitBoxSize ); if(projBBox.intersectsBox(playerBox)){ dealDamageToPlayer(proj.damage, proj.isBullet ? 'bullet' : 'gas_impact'); if(proj.isBullet) playSound(oyuncuHasarSesi); hit = true; hitPosition = playerPosition.clone(); } } if(hit){ if(proj.hitCallback) proj.hitCallback(hitPosition); if(proj.mesh) scene.remove(proj.mesh); projectiles.splice(i, 1); continue; } proj.position.copy(nextPosition); if(!proj.isBullet && proj.mesh){ proj.mesh.lookAt(nextPosition.clone().add(proj.velocity)); } if(proj.isBullet && playerHealth > 0 && gameState === 'PLAYING'){ const distanceToPlayer = proj.position.distanceTo(playerPosition); if(distanceToPlayer < 2.0 && Math.random() < 0.05){ playSound(mermiViziltiSesi, 0.3); } } } }

        function dealDamageToPlayer(amount, type = 'generic'){ if(playerHealth <= 0 || gameState !== 'PLAYING') return; playerHealth -= amount; lastDamageTime = clock.elapsedTime; showDamageEffect(camera.position); playSound(oyuncuHasarSesi); updateHealthStaminaUI(); if(playerHealth <= 0){ handlePlayerDeath(); } }
        function dealDamageToPolice(entity, amount){ if(!entity || entity.health <= 0) return; entity.health -= amount; createBloodEffect(entity.position.clone().add(new THREE.Vector3(0, entity.heightOffset * 0.6, 0))); playSound(polisHasarSesi); if(entity.mesh){ const originalMaterials = new Map(); entity.mesh.traverse((child) => { if(child.isMesh && child.material){ originalMaterials.set(child, child.material); const hitMaterial = child.material.clone(); hitMaterial.color.setHex(0xff0000); if(hitMaterial.emissive) hitMaterial.emissive.setHex(0x550000); child.material = hitMaterial; } }); setTimeout(() => { if(entity.mesh){ entity.mesh.traverse((child) => { if(child.isMesh && originalMaterials.has(child)){ child.material = originalMaterials.get(child); } }); } }, 100); } }
        function handlePlayerDeath(){ if(gameState === 'DEAD' || gameState === 'SUCCESS') return;
             gameState = 'DEAD'; playerHealth = 0; updateHealthStaminaUI(); isSprinting = false; targetFov = originalFov; camera.fov = originalFov; camera.updateProjectionMatrix(); stopPepperSprayScreenEffect(); olumEkrani.style.display = 'flex'; playSound(olumSesi);
              const sBC = document.querySelector('.durum_cubuklari_kapsayici'); if (sBC) sBC.style.display = 'none'; if (sloganSeviyeKapsayici) sloganSeviyeKapsayici.style.display = 'none'; if (mobilKontroller) mobilKontroller.style.display = 'none';
              if(controls && controls.isLocked){ controls.unlock(); } joystickActive = false; joystickDeltaX = 0; joystickDeltaY = 0; joystickMagnitude = 0; if(joystickCubugu) joystickCubugu.style.transform = `translate(-50%, -50%) translate(0px, 0px)`; lookActive = false; }

        function playSound(audioElement, volume = 0.5){ if(audioElement){ try { audioElement.currentTime = 0; audioElement.volume = Math.max(0, Math.min(1, volume)); const playPromise = audioElement.play(); if (playPromise !== undefined) { playPromise.catch(error => { }); } } catch(e) {console.error("Error playing sound:", e)} } }
        function onWindowResize(){ if(!camera || !renderer) return; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); checkOrientation(); }

        function animate() {
             requestAnimationFrame(animate);
             const deltaTime = Math.min(clock.getDelta(), 0.05);
             const elapsedTime = clock.getElapsedTime();
             try {
                 updateWorldChunks();
                 if(gameState === 'PLAYING'){
                     updatePlayer(deltaTime);
                     updateEntities(deltaTime);
                     updateProjectiles(deltaTime);
                     updateParticles(deltaTime);
                     animateMegaphone(deltaTime);
                     if(windLinesMesh) windLinesMesh.visible = isSprinting;
                 }
                 else if(gameState === 'MENU' && menuCameraAnimation.active){
                     const animSpeed = 0.04; const radius = CHUNK_SIZE * 1.2; const height = BASE_CITY_Y + 20 + Math.sin(elapsedTime * animSpeed * 0.6) * 6; const lookRadius = CHUNK_SIZE * 0.5;
                     camera.position.x = Math.sin(elapsedTime * animSpeed) * radius + CHUNK_SIZE / 2; camera.position.z = Math.cos(elapsedTime * animSpeed) * radius + CHUNK_SIZE / 2; camera.position.y = height;
                     const lookX = Math.sin(-elapsedTime * animSpeed * 0.4) * lookRadius + CHUNK_SIZE / 2; const lookZ = Math.cos(-elapsedTime * animSpeed * 0.4) * lookRadius + CHUNK_SIZE / 2; menuCameraAnimation.lookAtTarget.set(lookX, BASE_CITY_Y + 3, lookZ); camera.lookAt(menuCameraAnimation.lookAtTarget);
                     if(windLinesMesh) windLinesMesh.visible = false;
                     updateParticles(deltaTime);
                 }
                 else if(gameState === 'PAUSED' || gameState === 'DEAD' || gameState === 'SUCCESS'){
                     if(windLinesMesh) windLinesMesh.visible = false;
                     updateParticles(deltaTime);
                 }
                 if(renderer && scene && camera){
                     renderer.render(scene, camera);
                 }
             } catch(error) {
                 console.error("Hata oluştu:", error);
                 if(gameState === 'PLAYING'){
                     pauseGame();
                 }
                 showNotification("Kritik Hata Oluştu! Konsolu kontrol edin.");
             }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
